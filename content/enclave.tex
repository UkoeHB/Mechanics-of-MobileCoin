\chapter{SGX Secure Enclaves}
\label{chapter:enclaves}

As mentioned in previous chapters, all MobileCoin transactions are validated in {\em secure enclaves}. We claimed these enclaves are opaque boxes that can't be examined by even those who own them, making it possible to safely discard identifying information like ring signatures before appending transactions to the blockchain.

On the face of it, secure enclaves may seem preposterous. How can we be sure they validate transactions properly? If information must be passed into an enclave, can't we just read it before passing it in? How can a transaction author send their transaction to the network, and be sure only secure enclaves can read it? How could the entire blockchain be created from the output of these secure enclaves?

Perhaps some readers have heard about secure enclaves before, and realize they are not as robust as elliptic curve cryptography or hash functions. In the case of an enclave breach, will MobileCoin collapse under the weight of a mistaken security assumption?

This chapter aims to shed light on how secure enclaves work (specifically Intel's Software Guard Extensions [SGX] technology \cite{kudelski-sgx-secure-enclaves-review, intel-sgx-explained-advanced}), while Chapter \ref{chapter:blockchain} discusses how enclaves fit into the broader picture of consensuating transactions and growing the MobileCoin blockchain.



\section{An outline}
\label{sec:secure-enclave-outline}

Suppose you want to send data to a remote server and get back the results of some computations on it. Clearly, without any special techniques, the server's operator will be able to read the input data, and can return anything they want back to the user. Secure enclaves enable remote users to send data that can't be examined by the enclave operator, and be sure the results they get back actually came from the intended algorithm \cite{intel-sgx-explained-advanced}.


\subsection{Secure enclaves}
\label{subsec:simple-enclave-secure-enclave}

A secure enclave is a sectioned-off part of a computer not visible to, or modifiable by, anyone after it has been set up \cite{kudelski-sgx-secure-enclaves-review}. Whatever an enclave does with data passed in is determined by the software it is initialized with.

To pass data into an enclave, the data owner encrypts it using a public key associated with that enclave. Once inside the enclave, the encrypted packets are decrypted and consumed by the enclave's software. Depending how that software was designed, its outputs may be encrypted for transmission to the original data owner or another secure enclave, or sent in plaintext outside the enclave for use by the local machine.

An enclave may also encrypt some data for local `sealed' storage, which it can access and decrypt again at a later time.

At this point the data owner is still faced with two problems. 


\subsection{Chain of trust}
\label{subsec:simple-enclaves-chain-of-trust}

First, how can a data owner be sure the public key they encrypt their data with is specifically a secure enclave's public key? Public key cryptography is free to use for everyone.\footnote{Note that message/data encryption can be done by creating a Diffie-Hellman shared secret, breaking the message into chunks, and then XORing each chunk with a value (e.g.\ hash) computed based on the shared secret. The recipient learns your public key and encrypted message, and decrypts it by recomputing the mask values and XORing them with the encrypted chunks. MobileCoin's secure enclaves use a more sophisticated technique called AES \cite{AES-encryption} to process the message chunks, where key exchange for creating the AES `cipher key' relies on the Noise Protocol Framework \cite{noise-protocol-framework} (which involves several Diffie-Hellman exchanges between the communicating parties). A communication channel where both parties have the same private key (e.g.\ shared secret) is called {\em symmetric encryption} \cite{intel-sgx-explained-advanced}.}
%section 3.3.1

It turns out secure enclaves can't exist without specially designed hardware. Aside from the various details that go into making secure enclaves secure at the machine level, such hardware is manufactured with two secret values `baked in' (e.g.\ 128-bit integers). Each piece of hardware gets its own pair of secrets, one of which is known to the manufacturer and the other of which is not. These secret values are used to create all the cryptographic keys essential to securely setting up and running enclaves. As we will see, there is no way to extract the hardware secrets, since they are never directly exposed to enclave software. \cite{intel-sgx-explained-advanced}

Through a process we discuss in Section \ref{subsec:enclaves-sgx-provisioning} involving the hardware secrets, the manufacturer (e.g.\ Intel) cooperates with enclave-enabled machines to create `Attestation keys' that can be used by enclaves on those machines to prove a piece of data was produced by a secure enclave. For instance, a public key that can encrypt messages only readable by an enclave could be attested to.


\subsection{Remote attestation}
\label{subsec:simple-enclaves-remote-attestation}

The second problem faced by data owners is that secure enclaves may not be running the software they expect. If they send data to an enclave that just sends it right back out for the local operator to read, there would hardly be a point to using enclaves in the first place.

When a secure enclave is being `initialized' (see Section \ref{subsec:enclaves-sgx-initializing}), the software it is supposed to run is passed in (i.e.\ its compiled binary form). Part of the initialization procedure is to progressively hash that software, with the final output known as a `measurement hash'. \cite{intel-sgx-explained-advanced}

Once an enclave has been initialized, the software it runs can't be modified, so the measurement hash is a reliable representation of the enclave's software. The measurement hash is constructed automatically by secure CPU instructions, and is stored alongside that enclave in a data structure only accessible by other secure CPU instructions.%the sgx enclave control structure (SECS)

When an enclave-enabled machine uses its Attestation key to prove that a message was produced by an enclave, it includes that enclave's measurement hash with the proof. Anyone who validates the proof can be confident the message was produced by an enclave running the implied software, assuming they trust the enclave technology is not completely flawed and the enclave provider (Intel in our case) implemented each step of the process correctly and honestly.\\

Any person who wishes to interact with an enclave is responsible for verifying the measurement hash is correct, and the software it represents is well made. There are two general ways to do this.
\begin{enumerate}
    \item Obtain the measurement hash from a trusted source, who is assumed to have already validated the software. For example, the software developer who made it.
    \item Manually validate the software source code, and recreate the measurement hash. This only works if the software is deterministically reproducible \cite{reproducible-builds-debian-wiki}, which means the binary executable created by compiling the source code can be reproduced byte-for-byte when recompiling it (on the same or a different machine). The measurement hash can be recreated by anyone with the binary, so it is relatively easy to verify (no need for special hardware).\footnote{\label{footnote:sgx-recreate-mrenclave}See for example {\tt sdk/sign\_tool/SignTool/sign\_tool.cpp measure\_enclave()} from Intel's {\tt linux-sgx} library~\cite{intel-lib-linux-sgx}.}%Chris Beck says to look here: https://github.com/mobilecoinfoundation/mobilecoin/blob/master/sgx/build/src/sign.rs#L205
\end{enumerate}



\section{Filling in the gaps}
\label{sec:enclaves-fill-gaps-detailed}

So far we have sketched how secure enclaves work {\em in principle}. The rest of this chapter attempts to flesh out that sketch with theoretical and practical details pertinent to Intel's SGX secure enclave technology \cite{intel-sgx-product-page, sgx-manual}. Unfortunately enclaves are quite complicated, involve a lot of hardware-related implementation details, and have incomplete documentation \cite{kudelski-sgx-secure-enclaves-review}, so it is not feasible for us to explore everything that could be explored (e.g.\ threading, interrupts/exceptions, page eviction, and ECALLs/OCALLs for transitioning execution between an enclave and its host process are not addressed). See \cite{intel-sgx-explained-advanced} (especially chapter 5), \cite{sgx-101-sslab}, and \cite{sgx-manual} for advanced treatments of the subject, and any unanswered questions.\\

At this point, enclaves may still sound arcane and imprecise. In reality, they are quite similar to normal processes (e.g.\ applications, server code, etc.) that are ubiquitous on modern computers/servers. An enclave can be thought of as a `dynamically loaded library' (\cite{intel-sgx-explained-advanced} section 5.2) which is started up and then managed by a non-enclave host process throughout its lifetime.

Starting an enclave is analagous to starting any other process. A range of virtual memory (\cite{intel-sgx-explained-advanced} section 2.5.1) is assigned to the process (called the {\tt ELRANGE} for enclaves), and the process's intended executable code is loaded into that memory (\cite{intel-sgx-explained-advanced} section 5.3.2). The main differences between enclaves and normal processes are how memory is initialized, memory access rights, and the existence of secure CPU instructions only usable in the context of an enclave.


\subsection{SGX implementation}
\label{subsec:enclaves-sgx-implementation}

The implementation of SGX has four essential aspects: a so-called {\em Memory Encryption Engine}, hardware secrets, secure CPU instructions, and memory checks that enforce what memory software can access.

The presence of a Memory Encryption Engine (MEE) \cite{memory-encryption-engine-general-purpose-processors} in SGX-enabled hardware constitues the main deviation from normal Intel CPU design. It is a standalone module in the CPU's uncore, and exists to prevent physical attacks on memory (DRAM) allocated to secure enclaves (\cite{intel-sgx-explained-advanced} section 6.1.2). Aside from hardware secrets, all other parts of the SGX technology are implemented in microcode (\cite{intel-sgx-explained-advanced} section 6.1).\footnote{Microcode is essentially processor firmware \cite{debian-wiki-microcode}, meaning it is permanent or semi-permanent executable code embedded in the processor \cite{simple-wiki-firmware}. Its purpose is translating higher level CPU instructions into hardware-level CPU operations \cite{microcode-vs-firmware}.}\footnote{By implementing most of SGX in microcode, it is easier for Intel (relative to a hardware-heavy implementation) to both design and update it (\cite{intel-sgx-explained-advanced} section 6.1). Since SGX is so complex, it is prone to vulnerabilities \cite{wiki-sgx-attacks} that can only be addressed with security updates.}

\subsubsection{SGX hardware secrets}

SGX-enabled hardware include two random hardware secrets added during the manufacturing process.\footnote{Specifically, the secrets are burned into e-fuses. It is likely the secrets are encrypted with a `global wrapping logic key', another hardware secret that may be shared between different chips in the same production line, to make the e-fuse secrets harder to extract via physical analysis. The exact details are unknown or proprietary. (\cite{intel-sgx-explained-advanced} section 6.6.2 and \cite{sgx-security-analysis-mit-sanctum-architecture} section 2.6)} One of them, the {\em provisioning secret}, is generated in a secure facility, and a copy is stored permanently by Intel. The second, so-called {\em seal secret}, is created in-place within the CPU during production, and is discarded during the manufacturing process so it is only known to the device.\footnote{Intel documentation \cite{sgx-epid-provisioning-attestation} labels what \cite{intel-sgx-explained-advanced} calls the provisioning and seal secrets, `Root Provisioning Keys' (RPK) and `Root Seal Keys' (RSK) respectively. We go along with the unofficial convention for legibility.} (\cite{sgx-epid-provisioning-attestation} section 2.2)

\subsubsection{SGX CPU instructions}

Most of the SGX implementation is represented by a set of novel CPU instructions. These instructions are responsible for setting up enclaves, enabling entry to and exit from the enclave during code execution, and accessing hardware secrets for various parts of the remote attestation process. We will explore a number of instructions throughout the remainder of this chapter. Keep in mind only SGX CPU instructions can access the hardware secrets.

\subsubsection{SGX memory checks}

Based on its name, it would seem like the Memory Encryption Engine should be able to protect memory allocated to secure enclaves from being accessed and read by other processes. However, as it is designed to guard against physical attacks, the MEE is not well suited to addressing software-related problems. Instead, memory access checks are added to the `Page Miss Handler' so only the software running in an enclave can access the memory allocated to it. Enclave software can also freely access unprotected memory (i.e.\ memory not allocated to any enclave). Note that even an enclave's host application/process does not have access rights to the enclave's memory. (\cite{intel-sgx-explained-advanced} section 6.2)

Aside from the {\tt ELRANGE} memory which stores an enclave's code and data, there is also a separate (\cite{intel-sgx-explained-advanced} section 5.3.2) {\em SGX Enclave Control Structure} ({\tt SECS}) containing metadata about the enclave.\footnote{An enclave's {\tt SECS} is the first thing to be allocated when initializing an enclave, and the last to be destroyed when its life ends (\cite{intel-sgx-explained-advanced} section 5.1.3). Its content includes the enclave's measurements ({\tt MRENCLAVE} and {\tt MRSIGNER}, Section \ref{subsec:enclaves-sgx-measurements}), its attributes (bit flags that include the enclave's initialization state, whether debugging mode is on/off, and which architectural extensions were enabled when compiling the enclave executable code [\cite{intel-sgx-explained-advanced} section 5.2.2]), the enclave's size (a power of 2) and base virtual address (the {\tt SECS} is used by the SGX CPU instructions to locate the {\tt ELRANGE}), its product ID ({\tt ISVPRODID}), security version ({\tt ISVSVN}), and a few more obscure items. See \cite{sgx-manual} section 37.7 for a complete coverage of {\tt SECS} content.} The {\tt SECS} can only be read from or written to by the SGX CPU instructions. (\cite{intel-sgx-explained-advanced} section 5.1.3)


\subsection{SGX keys}
\label{subsec:enclaves-sgx-keys}

The hardware secrets are exclusively used as inputs to a key derivation process involving various information about an enclave. There are five SGX key variants that can be created, with different preconditions and input sets.\footnote{It is worth emphasizing again that only a few of the SGX CPU instructions can access the hardware secrets. In other words, SGX keys can only be created by those few instructions (there is one exception).} These keys are essential components of SGX, which must be understood before looking deeper at how SGX works.

\subsubsection{Key derivation}

Each key variant has a pre-defined set of inputs that are selected out of a larger input list. The inputs are collected together and treated as `key derivation material' for an AES key derivation algorithm (\cite{intel-sgx-explained-advanced} section 5.7.5). The algorithm's cipher key is based on the {\em Master Derivation Key}, which is a function of the provisioning secret and current SGX implementation's security version (\cite{sgx-epid-provisioning-attestation} section 2.1).\footnote{The Master Derivation Key for SGX implementations with old security versions can be recreated by implementations with newer security versions. This makes it easy to transfer data encrypted with old SGX keys to new versions, while the reverse transfer from new to old is prohibited by version control in the implementation. (\cite{sgx-epid-provisioning-attestation} section 2.1)}\vspace{.155cm}
\begin{align*}
    \textrm{\em Master Derivation Key} &= f(\textrm{\em provisioning secret}, \textrm{{\tt CPUSVN}}) \\
    \textrm{SGX\_key}_{variant\_type} &= \textrm{AES[ {\em Master Derivation Key }]}(\textrm{derivation material})
\end{align*}

Table \ref{table:sgx-key-derivation-material} summarizes the possible key derivation material (\cite{intel-sgx-explained-advanced} section 5.7.5). Unless noted with a section reference, we will not discuss any of the table entries in-depth, since they are mostly implementation minutiae covered extensively by \cite{intel-sgx-explained-advanced} and \cite{sgx-manual}.

%\newpage
\begin{tabularx}{\textwidth}{|l|X|}
\caption{Key Derivation Material}
\label{table:sgx-key-derivation-material}\\
\hline
    Input Type & Description \\
\hline\hline
    {\tt KEYNAME} & A two-byte representation of the key variant name. \\
\hline
    {\tt SEAL\_FUSES} & The hardware seal secret. \\
\hline
    {\tt KEYID} & A 32-byte random integer, ensuring new keys are always unique. \\
\hline
    {\tt MRENCLAVE} & An enclave measurement (Section \ref{subsec:enclaves-sgx-measurements}). \\
\hline
    {\tt MRSIGNER} & A hash of the public key used to sign an enclave (Section \ref{subsec:enclaves-sgx-measurements}). \\
\hline
    {\tt OWNEREPOCH} & A 16-byte random integer that can be reset whenever ownership of the hardware changes.\footnote{Including the owner epoch in key derivation material means new owners of the hardware can't decrypt the old owners' secrets, and the relevant SGX key variants can't be used to track hardware between owners. (\cite{intel-sgx-explained-advanced} section 5.7.5)} \\
\hline
    {\tt MASKEDATTRIBUTES} & A set of bit flags corresponding to attributes present in the enclave the key variant was created for. It is only a subset of that enclave's attributes.\footnote{SGX keys can only be created if the {\tt INIT} flag is set and the {\tt DEBUG} flag is not. (\cite{intel-sgx-explained-advanced} section 5.7.5)}\footnote{Only requiring a subset of enclave attributes in key derivation material allows secret migration between enclaves with different combinations of optional attributes. (\cite{intel-sgx-explained-advanced} section 5.7.5)} \\
\hline
    {\tt CPUSVN} & Security version number (SVN) of the SGX implementation.\footnote{The {\tt CPUSVN} is supposedly a concatenation of security versions corresponding to different components of the SGX implementation. (\cite{intel-sgx-explained-advanced} section 5.7.3)}\footnote{Although not stated explicitly, \cite{sgx-epid-provisioning-attestation} sections 2.1-2.2 imply the {\tt CPUSVN} is responsible for controlling the Master Derivation Key transformation function.} \\
\hline
    {\tt ISVSVN} & Security version number of an enclave's software, as designated by the enclave's author.\footnote{Enclave secrets can be migrated to an enclave with the same or higher {\tt ISVSVN}, but not lower. (\cite{intel-sgx-explained-advanced} section 5.7.2)} \\
\hline
    {\tt ISVPRODID} & Product ID of an enclave's software, as designated by the enclave's author.\footnote{Since SGX keys depend on the enclave product ID, secrets may not pass between enclaves with different IDs even if all other aspects of their identity are the same (measurements and security version) (\cite{intel-sgx-explained-advanced} section 5.7.5). This makes it possible to isolate enclaves with different IDs, although the utility of that is unclear.} \\
\hline
\end{tabularx}

\subsubsection{Key variants}

There are three SGX instructions that can create SGX keys. Instruction {\tt EGETKEY} can create all five variants, with a few restrictions on the enclaves allowed to call it (\cite{sgx-manual} pg.\ 40-111). Instructions {\tt EINIT} and {\tt EREPORT} compute the `Launch key' and `Report key', respectively. Note that {\tt EGETKEY} and {\tt EREPORT} are only callable from within an enclave's executable code (\cite{intel-sgx-explained-advanced} sections 5.7.5 and 5.8.1), while {\tt EINIT} is only called during the process of initializing an enclave (see Section \ref{subsec:enclaves-sgx-initializing}).

\begin{tabularx}{\textwidth}{|l|X|X|}
\caption{SGX Key Variants}
\label{table:sgx-key-variants}\\
\hline
    Key Variant Name &
    Description &
    {\tt EGETKEY} Restrictions\\
\hline\hline
    Seal key &
    Intended for migrating secrets between different versions of an enclave with the same author (\cite{intel-sgx-explained-advanced} section 5.7.5), or long-term storage of secrets (\cite{sgx-epid-provisioning-attestation} section 2.3). &
    None \\
\hline
    Report key &
    Used when an enclave makes a {\tt Report} to prove to another local enclave they had access to a piece of data (see Section \ref{subsec:enclaves-sgx-attestation}). &
    None \\
\hline
    Provisioning key &
    Allows a Provisioning enclave created by Intel to prove to an Intel provisioning service it is running securely on SGX-enabled hardware (see Section \ref{subsec:enclaves-sgx-provisioning}). &
    The calling enclave's {\tt PROVISION- KEY} attribute must be set. \\
\hline
    Provisioning Seal key &
    Similar to the Seal key, it is mainly used to transfer the Attestation key between the Provisioning and Quoting enclaves created by Intel (see Section \ref{subsec:enclaves-sgx-provisioning}). &
    The calling enclave's {\tt PROVISION- KEY} attribute must be set. \\
\hline
    Launch key &
    Used to make an {\tt EINIT Token} that indicates to the {\tt EINIT} instruction that an enclave being initialized was approved by a valid Launch enclave (see Section \ref{subsec:enclaves-sgx-initializing}). &
    The calling enclave's {\tt EINITTOKEN} attribute must be set, and its {\tt SECS.MRSIGNER} field must equal the key hash {\tt IA32\_SGXLEPUBKEY- HASH} embedded in the SGX implementation (see Section \ref{subsec:enclaves-sgx-initializing}).\\
\hline
\end{tabularx}

We will point out the significance of the {\tt EGETKEY} restrictions in future sections that also discuss how and when each key variant is used. The Seal key won't be explored further, since it's just a normal key used to encrypt secrets. Generally it is best to avoid storing secrets long-term due to the risk of enclave security breaches, although as we will see in Section \ref{subsec:fog-missed-blocks}, sealing secrets is useful in case a device is power-cycled (or an enclave's host process crashes).

\subsubsection{Creating a key}

Table \ref{table:egetkey-key-variant-patterns} (based on table 3 of \cite{sgx-epid-provisioning-attestation} and table 40-64 of \cite{sgx-manual}) details the key derivation material of each key variant when created by {\tt EGETKEY} (except items that are present in all variants, such as the key name).\footnote{{\tt EINIT} and {\tt EREPORT} obtain their key derivation material with different methods, as noted.} Table value `Direct' corresponds with items that {\tt EGETKEY} pulls directly from the enclave (e.g.\ hardware secrets, SGX implementation security version, stuff from the {\tt SECS} structure), while `Input' signifies items pulled from a `key request' passed as input to {\tt EGETKEY}.

%\newpage
\begin{tabularx}{1pt}{|c|c|c|c|c|c|c|c|c|c|}
\caption{{\tt EGETKEY} Key Derivation Material Per Key Variant}
\label{table:egetkey-key-variant-patterns}\\
\hline
    Key Variant Name &
    \rotatebox{90}{{\tt SEAL\_FUSES}} &
    \rotatebox{90}{{\tt KEYID}}\footnote{Intel documentation (table 3 of \cite{sgx-epid-provisioning-attestation} and table 40-64 of \cite{sgx-manual}) implies {\tt EGETKEY} generates {\tt KEYID} for the Provisioning and Provisioning Seal keys (by stating the value is obtained directly). However, in (\cite{intel-sgx-explained-advanced} section 5.8.2) the {\tt KEYID} is left blank for Provisioning keys. Our interpretation is the Provisioning-type keys use a `default' value for the {\tt KEYID}, which could be a hard-coded value or simply 32 zero bytes. This idea is reinforced by how the Provisioning key is used during attestation (see \cite{intel-lib-linux-sgx} and Section \ref{subsec:enclaves-sgx-provisioning}), where the {\tt KEYID} isn't transmitted to a third-party who needs to recompute Provisioning keys (they must know the value to use in advance, hence a default of some kind).} &
    \rotatebox{90}{{\tt MRENCLAVE}} &
    \rotatebox{90}{{\tt MRSIGNER}} &
    \rotatebox{90}{{\tt OWNEREPOCH}} &
    \rotatebox{90}{{\tt MASKEDATTRIBUTES }}\footnote{For {\tt MASKEDATTRIBUTES}, `Input' means the field is set by bitwise AND between the enclave's {\tt ATTRIBUTES} and an input {\tt ATTRIBUTEMASK}, while `Direct' means the field is set equal to the enclave's {\tt ATTRIBUTES}.} &
    \rotatebox{90}{{\tt CPUSVN}}\footnote{If the {\tt CPUSVN} is a key request input, then it must be less than or equal to the current SGX implementation's security version. (\cite{intel-sgx-explained-advanced} section 5.7.5)} &
    \rotatebox{90}{{\tt ISVSVN}}\footnote{The {\tt ISVSVN} is always input to {\tt EGETKEY} (et al.) explicitly. Wherever used, it must be less than or equal to the security version of the enclave that calls {\tt EGETKEY}. Incidentally, this implies Provisioning Seal keys can usually only encrypt secrets for enclaves that share an {\tt ISVSVN} (the {\tt MRENCLAVE} is left out, so the key can potentially be recreated by a different enclave). Those keys are mainly or even exclusively used to pass Attestation keys [Section \ref{subsec:enclaves-sgx-provisioning}] from the Provisioning enclave to the Quoting enclave, which are paired together by design, so this limitation makes sense.} &
    \rotatebox{90}{{\tt ISVPRODID}} \\
\hline\hline
    Seal key\footnote{\label{footnote:sgx-seal-key-keypolicy}{\tt EGETKEY} has an input called the {\tt KEYPOLICY}, which lets the user decide if the {\tt MRENCLAVE}, {\tt MRSIGNER}, or {\tt ISVPRODID} should be left out of the Seal key (i.e.\ set to zero). This input is also used by other keys for some different, more obscure details. See \cite{sgx-manual} pg.\ 40-111 through 40-118 and section 37.18.2.} &
    Direct &
    Input &
    Direct &
    Direct &
    Direct &
    Input &
    Input &
    Input &
    Direct \\
\hline
    Report key\footnote{If a Report key is created by {\tt EREPORT} for a target enclave, then the target enclave's {\tt MRENVLAVE} and {\tt ATTRIBUTES} are taken as inputs, and the {\tt KEYID} is populated from a {\tt CR\_REPORT\_KEYID} field randomly generated each time the SGX-enabled hardware is restarted (\cite{sgx-manual} pg.\ 40-123). The target enclave's {\tt ATTRIBUTES} are used directly, not a subset of them. This design works because the key is being created for a specific enclave that currently exists on the same machine, rather than generically for an enclave that {\em might} exist on the current machine.} &
    Direct &
    Input &
    Direct &
    - &
    Direct &
    Direct &
    Direct &
    - &
    - \\
\hline
    Provisioning key &
    - &
    - &
    - &
    Direct &
    - &
    Input &
    Input &
    Input &
    Direct \\
\hline
    Provisioning Seal key &
    Direct &
    - &
    - &
    Direct &
    - &
    Input &
    Input &
    Input &
    Direct \\
\hline
    Launch key\footnote{The {\tt EINIT} instruction also computes the Launch key, to validate {\tt EINIT tokens}. It takes as input all parts of the Launch key's derivation material except the seal secret and owner epoch. This may seem strange, since it implies {\em any} enclave could make an {\tt EINIT token} that would be considered valid by {\tt EINIT}. As we will see (Section \ref{subsec:enclaves-sgx-initializing}), since {\tt EGETKEY} restricts which enclaves can make Launch keys, construction of {\tt EINIT tokens} is also restricted. By extension, this enables the {\tt EINIT} instruction to filter out `improperly' launched enclaves.} &
    Direct &
    Input &
    - &
    - &
    Direct &
    Input &
    Input &
    Input &
    Direct \\
\hline
\end{tabularx}

Keys can only be reconstructed if all their key derivation material is available, so typically information that is passed as an input to {\tt EGETKEY} is stored alongside the key produced. See \cite{intel-sgx-explained-advanced} chapter 5 for all the minor details, especially for the Report and Launch keys produced by {\tt EREPORT} and {\tt EINIT}.

We will not justify the different sets of key derivation material, in the interest of space. For an example of why a piece of information may be neglected from the key derivation, take the Provisioning key. It is the only key that does not use the seal secret, because the key is designed to be reproducible by Intel's provisioning service (Section \ref{subsec:enclaves-sgx-provisioning}), which does not know that value. All other keys {\em do} have the seal secret because they are supposed to be reproducible by only SGX CPU instructions.


\subsection{SGX measurements}
\label{subsec:enclaves-sgx-measurements}

Before diving into the meaty parts of SGX (Sections \ref{subsec:enclaves-sgx-initializing}, \ref{subsec:enclaves-sgx-provisioning}, \& \ref{subsec:enclaves-sgx-attestation}), we should also briefly introduce the two measurements {\tt MRENCLAVE} and {\tt MRSIGNER} that were mentioned earlier in this chapter.

\subsubsection{Measurement {\tt MRENCLAVE}}

The {\tt MRENCLAVE} is a measurement of an enclave's content; specifically, the binary code it is always initialized with (plus a few details about how the enclave will be organized when set up). It is constructed with the 256-bit SHA-2 hash function (a.k.a.\ SHA-256) (\cite{sgx-manual} section 38.4.1.1).

SHA hash functions are known as {\em block hash functions}, which first `initialize' their internal state with initial values, then consume message chunks/blocks to `extend' the hashed message, and at the end `finalize' the hash by translating their internal state into a hash output. The hash function SHA-256 breaks the message-to-be-hashed into 64-byte blocks, has a 32-byte internal state, and outputs a 32-byte digest. (\cite{intel-sgx-explained-advanced} section 3.1.3)

Since the measurement hash just depends on an enclave's initial content and SHA-256 (see Section \ref{subsec:enclaves-sgx-initializing}), it can be easily computed without relying on any SGX CPU instructions (recall footnote~\ref{footnote:sgx-recreate-mrenclave}).

\subsubsection{Measurement {\tt MRSIGNER}}

Enclave authors provide a so-called {\tt SIGSTRUCT} to potential users of an enclave. It contains the enclave's {\tt MRENCLAVE}, miscellaneous metadata (like attributes the enclave is allowed to have and its security version), and the author's signature on that information (using the RFC 3447 \cite{RSA-sig-RFC-3447} RSA signature scheme [\cite{intel-sgx-explained-advanced} section 5.7.1]).\footnote{This kind of message/signature combination is known as a `certificate' (see \cite{intel-sgx-explained-advanced} section 3.2).} Users must pass that {\tt SIGSTRUCT} (laid out in Table \ref{table:sgx-sigstruct} [\cite{intel-sgx-explained-advanced} section 5.9.1]) as an input when initializing the corresponding enclave.

\begin{tabularx}{\textwidth}{|l|X|}
\caption{{\tt SIGSTRUCT} Contents}
\label{table:sgx-sigstruct}\\
\hline
    Struct Field & Description \\
\hline\hline
    {\tt ATTRIBUTES} & Attributes the enclave must have when instantiated. \\
\hline
    {\tt ATTRIBUTEMASK} & The {\tt SIGSTRUCT}'s attributes must equal the bitwise AND between instantiated enclaves' real attributes and the attribute mask.\footnote{In more detail, the {\tt SIGSTRUCT}'s attributes and attribute mask work together to prevent instantiated enclaves from having disallowed attributes, while leaving room for optional and required attributes. There are three useful attribute/mask bit combinations. If both are true, then the attribute is required. If just the attribute bit is false, then the attribute is disallowed (real attribute \& mask bit must equal zero, only possible if real attribute isn't present). If both are false, then the attribute is optional (whether or not the real attribute is set, will have no affect on the attribute test). If just the mask is false, then it is impossible for the test to work, and the enclave will always be rejected (hence it's not a useful combination).} \\
\hline
    {\tt VENDOR} & Indicates if the enclave was produced by Intel. Typically `0' if not. It's not clear if this offers any utility. \\
\hline
    {\tt DATE} & Defined by the enclave author (e.g.\ the struct's signer). Possibly allows users to identify how old an enclave is. \\
\hline
    {\tt ENCLAVEHASH} & Expected {\tt MRENCLAVE} measurement of the enclave. \\
\hline
    {\tt ISVPRODID} & Enclave product ID defined by enclave author. Used to populate the corresponding {\tt SECS} field (\cite{intel-sgx-explained-advanced} section 5.7.4). \\
\hline
    {\tt ISVSVN} & Enclave security version defined by enclave author. Used to populate the corresponding {\tt SECS} field. \\
\hline
    RSA Signature & An RSA signature on the rest of the {\tt SIGSTRUCT}, containing \{exponent, modulus, signature, Q1, Q2\}.\footnote{The terms Q1 and Q2 in the {\tt SIGSTRUCT} RSA signature are temporary values that make verifying it easier, likewise with the exponent which is the integer `3'. (\cite{intel-sgx-explained-advanced} section 6.5)} The signature's `modulus' constitutes the signer's public key, and its SHA-256 hash is the {\tt MRSIGNER} value. \\
\hline
\end{tabularx}

During enclave initialization (Section \ref{subsec:enclaves-sgx-initializing}), the {\tt SIGSTRUCT}'s signature is verified, and the {\tt MRSIGNER} field in the {\tt SECS} structure is set to the SHA-256 hash of the signature's public key. Since the {\tt SECS} structure (mentioned in Section \ref{subsec:enclaves-sgx-implementation}) can only be accessed by SGX CPU instructions, the {\tt MRSIGNER} is sufficient proof post-initialization of who authored an enclave.

The {\tt MRSIGNER} is required for identity-based privileged attribute checks in {\tt EINIT} and the Launch enclave (Section \ref{subsec:enclaves-sgx-initializing}). More generally, it allows an enclave author to safely migrate secrets between versions of their enclaves, since {\tt MRSIGNER} can be part of the key derivation material for Seal keys (\cite{sgx-manual} section 38.4.1.2). If there was no {\tt MRSIGNER}, then anyone could create a `new' version of a given enclave and trivially expose any secrets the original enclave had sealed.\footnote{\label{footnote:enclave-secret-migration-dangerous}Even adding the {\tt MRSIGNER} restriction to Seal keys, allowing secret migration between enclave versions is still dangerous. The enclave author's private keys could become compromised, or the author himself may be malicious. MobileCoin does not allow any enclave secrets to persist between enclave versions, in part due to these dangers.}%[[[MC comment needs citation? or delete? hmm]]]


\subsection{SGX enclave initializing}
\label{subsec:enclaves-sgx-initializing}

Initializing an SGX enclave takes four basic steps. After it is initialized, the enclave's executable binary is static, and only that binary is able to read and edit the enclave's internal malleable state.

Enclaves are loaded in 4 KB units, called `Enclave Page Cache (EPC) pages', to harmonize with the 4 KB page size of the address translation feature in Intel's CPU architecture (\cite{intel-sgx-explained-advanced} section 5.1.1). To ensure all enclaves are set up the same, enclave authors must specify the enclave `memory layout'. In other words, what initial content should be loaded into which pages within the {\tt ELRANGE}, and what access restrictions those pages should have (i.e.\ a page with executable code, or a page readable/writable by enclave code [\cite{intel-sgx-explained-advanced} section 5.2.3]).

\subsubsection{Step 1: Assigning virtual memory}

An enclave's life starts with the {\tt ECREATE} SGX CPU instruction.

\begin{itemize}
    \item {\tt ECREATE}: A free EPC page is commandeered to be the enclave's {\tt SECS}, and initialized. In the {\tt SECS}, there is an {\tt ATTRIBUTES} field containing all the enclave's attributes. One such attribute is the {\tt INIT} flag, which starts out false. Only when {\tt INIT} is false can data be added to the initial enclave state. Presumably the {\tt ELRANGE} is also set up by this instruction. (\cite{intel-sgx-explained-advanced} section 5.3.1)

    To reiterate, the {\tt ELRANGE} is a range of virtual memory (composed of EPC pages) which, once assigned, can only be modified by SGX CPU instructions. The enclave's {\tt SECS} is an EPC page containing metadata about the enclave exclusively accessible and modifiable by SGX CPU instructions throughout its lifetime, which does not reside within the {\tt ELRANGE}.

    An enclave's measurement begins here as well. The SHA-256 algorithm is initialized and extended with the first 64-byte block. That block is composed of: \{``ECREATE" (i.e.\ the string in byte form), SSA frame size (`State Save Area' for saving state when an exception is encountered that forces the processor to leave the enclave [\cite{intel-sgx-explained-advanced} section 5.2.5]), {\tt ELRANGE} size (number of EPC pages allocated to the enclave), padding\}.\footnote{Enclave attributes are not included anywhere in the measurement hash, in case the enclave author wants a single measurement to be valid for multiple attribute permutations. An enclave's attributes include the enclave extensions it is allowed to use, but multiple combinations of extensions may be considered valid. Instead, attribute information is included with the attestation signature, so remote users can verify if the attributes are within a legitimate range of possibilities (\cite{intel-sgx-explained-advanced} section 5.6.2).} (\cite{intel-sgx-explained-advanced} section 5.6.1)
\end{itemize}

\subsubsection{Step 2: Loading the enclave}

Next, the enclave executable code and initial data are loaded into the {\tt ELRANGE} by SGX instructions {\tt EADD} and {\tt EEXTEND}, which also extend the enclave measurement hash based on the bytes loaded in. These instructions only work if the {\tt INIT} flag is false.

\begin{itemize}
    \item {\tt EADD}: To load a new non-enclave page into the {\tt ELRANGE}, its location in memory is connected with the intended EPC page virtual address in a {\tt PAGEINFO} structure by {\tt EADD}. That structure also references the enclave's {\tt SECS} and the new page's access restrictions (readable/writable/executable). It can be thought of as a metadata `header' for preparing a new page to be loaded. (\cite{intel-sgx-explained-advanced} section 5.3.2)

    Once a new page is prepared, it is copied from non-enclave memory into the appropriate EPC page by {\tt EADD}. (\cite{sgx-manual} section 38.1.2)

    Each {\tt EADD} instruction extends the measurement hash with a 64-byte block composed of \{``EADD", expected virtual address of EPC page to be added, {\tt PAGEINFO} containing \{enclave page type (it can be a regular code/data page, or a special `Thread Control Structure' for dealing with multithreaded enclaves), access permissions\}\}.\footnote{Forcing the measurement hash to be dependent on the memory layout and access permissions of each page ensures the main part of each enclave is fully deterministic when initialized by different enclave operators.} (\cite{intel-sgx-explained-advanced} section 5.6.3)

    \item {\tt EEXTEND}: After an EPC page has been initialized by {\tt EADD}, its contents are divided into 256-byte chunks for updating the measurement hash. This implies it takes 16 {\tt EEXTEND} instructions to fully measure a 4 KB page. (\cite{sgx-manual} section 38.1.2)

    Each {\tt EEXTEND} instruction extends the measurement hash with five 64-byte blocks. The first block contains \{``EEXTEND", enclave offset (i.e.\ relative location of the 256-byte chunk within the {\tt ELRANGE} [\cite{sgx-manual} pg.\ 40-45]\footnote{The precise nature of the enclave offset is not clearly stated in Intel's documentation, however the sample code on page 40-45 of \cite{sgx-manual} implies it is the relative location of the 256-byte chunk within the {\tt ELRANGE}, rather than the relative location of the page itself as described by \cite{intel-sgx-explained-advanced} sections 5.3.2 and 5.6.4.}), padding\}, and the remaining four blocks divide up the 256-byte chunk. (\cite{intel-sgx-explained-advanced} section 5.6.4)
\end{itemize}

\subsubsection{Step 3: {\tt EINIT token} (and the Launch enclave)}

In Table \ref{table:sgx-key-variants}, we indicated Provisioning and Provisioning Seal keys can only be produced by {\tt EGETKEY} when the enclave that calls it has the {\tt PROVISIONKEY} attribute set. Without further restrictions, that attribute check would be fairly pointless, as any enclave author could set the flag arbitrarily.

It is useful to restrict which enclaves can make these keys because there is no {\tt OWNEREPOCH} in their key derivation material (recall Table \ref{table:egetkey-key-variant-patterns}). To recap, the owner epoch is a random value stored in an Intel machine that can be reset whenever ownership of that machine changes (Table \ref{table:sgx-key-derivation-material}). Keys derived without the owner epoch allow a malicious enclave to `track' a piece of hardware across ownership changes, and let new owners decrypt secrets previously encrypted with those keys. (\cite{intel-sgx-explained-advanced} section 5.7.5)

Therefore, it is beneficial to owners of SGX-enabled hardware to limit which enclaves may have the {\tt PROVISIONKEY} attribute. As \cite{intel-sgx-explained-advanced} points out in section 5.9.3, it is technically possible to implement a launch control policy for enclaves in system software. Such a policy would prevent an enclave with the {\tt PROVISIONKEY} attribute set from being initialized/launched if its contents ({\tt MRENCLAVE}) or author ({\tt MRSIGNER}) are not in a pre-approved list. Unfortunately, Intel does not allow owners of SGX-enabled hardware to implement a launch control policy purely ad hoc. Instead, the policy must be implemented in a so-called `Launch enclave', which is required for enclave initialization.

A launch enclave takes as input an enclave-being-launched's {\tt SIGSTRUCT} and its intended attributes. It outputs an {\tt EINIT token} signifying it approves of the enclave being launched. This token is a required input to the {\tt EINIT} CPU instruction (step 4, discussed next), and is constructed based on a Launch key made by {\tt EGETKEY}. Furthermore, as we will see, only a Launch enclave provided (i.e.\ signed) by Intel is allowed to make Launch keys via {\tt EGETKEY}. The net effect of this is enclaves can only be initialized based on the approval of a Launch enclave obtained from Intel.\footnote{On a subset of SGX-enabled hardware, it is possible to set up `Flexible Launch Control' \cite{sgx-flexible-launch-control-update} and implement a custom Launch enclave \cite{sgx-reference-launch-enclave}. Based on \cite{sgx-reference-launch-enclave}, it seems FLC-type Launch enclaves do not require approval from Intel. We may investigate FLC and related techniques \cite{sgx-supporting-third-party-attestation} for reducing Intel's role in using SGX enclaves in future editions of this report.} Table \ref{table:einit-token-contents} details the content of an {\tt EINIT token}.

\begin{tabularx}{\textwidth}{|l|X|}
\caption{{\tt EINIT token} Contents}
\label{table:einit-token-contents}\\
\hline
    Token Field & Description \\
\hline\hline
    {\tt MAC} & Basically a hash of the next four token fields ({\tt ATTRIBUTES} thru {\tt MRSIGNER}) and a Launch key (recall Section \ref{subsec:enclaves-sgx-keys}) created by calling {\tt EGETKEY} from the Launch enclave.\footnote{The {\tt EINIT token}'s {\tt MAC} is produced by the AES-CMAC algorithm. (\cite{intel-sgx-explained-advanced} section 5.9.1)} \\
\hline
    {\tt ATTRIBUTES} & The enclave-being-launched's intended attributes (an input to the Launch enclave). \\
\hline
    {\tt VALID} & A true/false flag indicating if the Launch enclave considers the enclave-being-launched valid or invalid (i.e.\ the launch control policy's verdict). \\
\hline
    {\tt MRENCLAVE} & Measurement of the enclave-being-launched (from its {\tt SIGSTRUCT}). \\
\hline
    {\tt MRSIGNER} & SHA-256 hash of the public key used to sign the enclave-being-launched (from its {\tt SIGSTRUCT}). \\
\hline
    {\tt ISVSVNLE} & The Launch enclave's security version. For recreating the Launch key.\\
\hline
    {\tt KEYID} & A random number used to make the Launch key unique. For recreating the Launch key. \\
\hline
    {\tt CPUSVNLE} & The SGX implementation's security version, as used to make the Launch key. For recreating the Launch key. \\
\hline
    {\tt ISVPRODIDLE} & The Launch enclave's product ID. For recreating the Launch key. \\
\hline
    {\tt MASKEDATTRIBUTESLE} & A subset of the Launch enclave's attributes. For recreating the Launch key. \\
\hline
\end{tabularx}

Only if the {\tt SIGSTRUCT} is signed with an Intel public key will the Launch enclave allow the {\tt PROVISIONKEY} attribute to be set in the enclave-being-launched's intended attributes (\cite{sgx-reference-launch-enclave}, \cite{intel-sgx-explained-advanced} section 5.9.1).\footnote{It is not made clear in \cite{intel-sgx-explained-advanced} or \cite{sgx-manual} if the Launch enclave contains a hard-coded Intel key (or set of keys), or if it somehow uses the {\tt IA32\_SGXLEPUBKEYHASH} value embedded in the SGX implementation to check {\tt SIGSTRUCT} signer keys. It is also not clear if the launch control policy is applied to the {\tt SIGSTRUCT} attributes (which are constraints on what the real attributes may be) or the intended attributes. The FLC-type reference Launch enclave implementation at \cite{intel-lib-linux-sgx} {\tt /psw/ae/ref\_le/ref\_le.cpp ref\_le\_get\_launch\_token()} implies it is the intended attributes that are controlled. Moreover, the {\tt EINIT token MAC} uses the intended attributes directly, implying they have a central role in the launch control policy. These are implementation details and ultimately don't affect the observable behavior of the Launch enclave, especially since the {\tt EINIT} instruction is quite rigorous about checking for attribute inconsistencies.} That is the entirety of the launch control policy as far as the documentation reveals. In practice, only Intel's Provisioning enclave (Section \ref{subsec:enclaves-sgx-provisioning}) and Quoting enclave (Section \ref{subsec:enclaves-sgx-attestation}) are allowed to have the {\tt PROVISIONKEY} attribute.

\subsubsection{Step 4: {\tt EINIT}}

Finally, the {\tt EINIT token} and {\tt SIGSTRUCT} are passed to the {\tt EINIT} instruction, which finalizes the measurement hash, verifies the {\tt EINIT token} and {\tt SIGSTRUCT} signature, ensures the enclave doesn't have any attributes not permitted by the {\tt SIGSTRUCT}, sets several values in the {\tt SECS} structure based on the {\tt SIGSTRUCT}, and marks the enclave as initialized to prevent any further modifications. It is instructive to directly enumerate the steps taken, as described by Intel's SGX developer manual (\cite{sgx-manual} pg.\ 40-47 to 40-52; the exact order of steps may not fully match the SGX implementation, and some trivial or obscure steps are left out).

\begin{enumerate}
    \item Complete the enclave's measurement by finalizing the SHA-256 algorithm (translating the algorithm's internal state into a hash output). The final value is stored in the enclave's {\tt SECS.MRENCLAVE} field.\footnote{In fact, during initialization the intermediate measurement hash values are also stored in the {\tt SECS.MRENCLAVE} field for convenience and to isolate them from unauthorized modification (only the SGX CPU instructions can read from, and write to, the {\tt SECS} structure). (\cite{intel-sgx-explained-advanced} section 5.6)}

    \item {\tt SIGSTRUCT} checks:
    \begin{enumerate}
        \item Verify the {\tt SIGSTRUCT}'s signature.

        \item Check if the {\tt SIGSTRUCT}'s {\tt ENCLAVEHASH} matches the final {\tt MRENCLAVE} value.

        \item Check if the enclave's real attributes are permitted by its author. Bitwise AND between {\tt SECS.ATTRIBUTES} and {\tt SIGSTRUCT.MASKEDATTRIBUTES} must equal {\tt SIGSTRUCT.ATTRIBUTES}.
    \end{enumerate}
    
    \item Set the {\tt SECS} fields {\tt SECS.MRSIGNER}, {\tt SECS.ISVPRODID}, and {\tt SECS.ISVSVN} by copying the corresponding values from the {\tt SIGSTRUCT} (recall the {\tt MRSIGNER} is computed as a SHA-256 hash of the enclave author's public key, as found in the {\tt SIGSTRUCT}).

    \item Check if the {\tt LAUNCHKEY} attribute is not set in {\tt SECS.ATTRIBUTES} unless the enclave's {\tt MRSIGNER} equals a value known as {\tt IA32\_SGXLEPUBKEYHASH} (a.k.a.\ `SGX Launch enclave public key hash'), which is embedded in the SGX implementation.

    \item {\tt EINIT token} checks:
    \begin{enumerate}
        \item If the token is marked invalid, make sure the {\tt SECS.MRSIGNER} value equals {\tt IA32\_SGXLE- PUBKEYHASH}, then skip the other token checks.

        \item Use the token contents to compute the Launch key and verify the token's {\tt MAC}. This computation is integrated directly into {\tt EINIT}, and is a sort of duplicate implementation of {\tt EGETKEY:LAUNCHKEY}.

        \item Verify the token's {\tt MRSIGNER} value matches the {\tt SECS.MRSIGNER} value. Also check the corresponding {\tt MRENCLAVE} values.

        \item Check if the token's `intended attributes' field matches the enclave's real attributes ({\tt SECS.ATTRIBUTES}).
    \end{enumerate}

    \item If all checks pass, mark the enclave as initialized by setting the {\tt SECS.INIT} flag.
\end{enumerate}

The reader may have noticed we snuck a crucial design detail into the list. Enclaves signed by Intel's public key, which is hard coded into Intel's SGX implementation, can get past {\tt EINIT} without a valid {\tt EINIT token}. This provides a path to `bootstrap' enclave launching. First launch Intel's Launch enclave, then use it to make {\tt EINIT token}s for launching all other enclaves.


\subsection{SGX provisioning}
\label{subsec:enclaves-sgx-provisioning}

To achieve untrusted remote computation, secure enclave owners must prove they are running enclaves with software expected by remote parties. It isn't enough that the {\em owners} know they are running secure enclaves. Since secure enclaves are ultimately a processor technology, remote computation proofs must be connected to the relevant processor manufacturer (e.g.\ Intel).

In short, the enclave-enabled hardware proves knowledge of the provisioning secret to its manufacturer (who also knows that secret), the manufacturer provisions an `Attestation key' to the hardware signifying it trusts the hardware, enclaves on that machine use the Attestation key to sign their messages, the manufacturer verifies those signatures and filters out compromised signers (a capability of the EPID signing protocol \cite{epid-paper}) before re-signing it, and final recipients of messages check the manufacturer's signatures against a trusted public key. We discuss provisioning in this section, and attestation in the next.

\subsubsection{Provisioning enclave}

%primary source for provisioning (from Yogesh Swami): https://github.com/intel/linux-sgx/blob/4589daddd58bec7367a6a9de3fe301e6de17671a/psw/ae/pce/pce_helper.cpp

Provisioning is orchestrated by a `Provisioning enclave' signed by Intel.\footnote{According to \cite{sgx-extending-sgx-autonomy-and-anonymity-thesis} and \cite{sgx-remote-attestation-is-not-sufficient}, provisioning is designed by Intel to use two enclaves (the `Provisioning enclave' and `Provisioning Certification enclave'), however \cite{sgx-overview-part-2-externals-quarkslab} claims (without direct citation) these are implemented in practice as one combined enclave. It seems at least Intel's Linux implementation uses separate enclaves \cite{intel-lib-linux-sgx}. For simplicity, we assume there is only one enclave. The main purpose of splitting out the certification enclave appears to be encapsulating a check on the {\tt PROVISIONKEY} attribute, such that the certification enclave will only produce the PPID for authorized enclaves, and also to provide a rigorous process for `certifying' that an enclave is so authorized~\cite{intel-lib-linux-sgx}.} This is one of the enclaves allowed by the Launch enclave to have the {\tt PROVISIONKEY} attribute (Section \ref{subsec:enclaves-sgx-initializing}, step 3). We recommend \cite{sgx-extending-sgx-autonomy-and-anonymity-thesis} section 2.4.5.1, \cite{sgx-remote-attestation-is-not-sufficient}, and especially \cite{intel-lib-linux-sgx} for a more complete picture of the provisioning process than is laid out here.%\footnote{Parts of this section were drawn from \cite{sgx-extending-sgx-autonomy-and-anonymity-thesis} section 2.4.5.1 and \cite{sgx-remote-attestation-is-not-sufficient}, which contain weak or nonexistent in-line citations. However, the second paper based its treatment of this topic on Intel's Linux implementation \cite{intel-lib-linux-sgx} according to private correspondence with the author.}

Intel obtains a copy of a hardware's provisioning secret during the manufacturing process. Moreover, that hardware can only use the provisioning secret to create SGX keys, of which only the Provisioning key can be made by Intel (all other keys use the seal secret). Therefore, for a piece of hardware to prove it is SGX-enabled, it must create a Provisioning key that Intel can verify was created by a provisioning secret stored in their database.

However, how can Intel know which provisioning secret to use, to recreate a given Provisioning key it is presented with? It is unreasonable to test {\em all} secrets in its database, so Intel must use an identifier of some kind to locate the relevant provisioning secret.

Intel's solution has two steps:
\begin{enumerate}
    \item The Provisioning enclave uses {\tt EGETKEY} to produce a Provisioning key, with the {\tt CPUSVN} and {\tt ISUSVN} values explicitly set to zero. A hash of that key, called the Provisioning ID (PPID), is sent to Intel (in encrypted form, as is standard for network communications). Intel can pre-compute the PPID for all stored provisioning secrets, making it easy to connect provisioning requests with secrets created during manufacturing.\footnote{The SGX implementation and enclave security versions are left out of the PPID to ensure it is a value that will remain constant forever. Note that, per Table \ref{table:egetkey-key-variant-patterns}, the {\tt MRSIGNER} and {\tt ISVPRODID} are still a part of the PPID, so in practice only Provisioning enclaves signed by Intel can create useful PPIDs.}
    \item The Provisioning enclave produces a second Provisioning key, this time with the real {\tt CPUSVN} and {\tt ISUSVN} values, and sends it to Intel. Intel can reproduce this new key using the provisioning secret associated with the previous step's PPID, along with the security versions that are also transmitted in this step. Intel can block provisioning requests from machines with insecure SGX or Provisioning enclave implementations.
\end{enumerate}

In practice \cite{sgx-remote-attestation-is-not-sufficient}, the second step could be merged with the first, or woven into the EPID Join protocol which is discussed next.

\subsubsection{EPID Join protocol}

Rather than give an Attestation key directly to the SGX-enabled hardware, Intel's provisioning service collaborates with the Provisioning enclave on an `EPID Join protocol' (\cite{epid-paper}, \cite{sgx-extending-sgx-autonomy-and-anonymity-thesis} section 2.4.5.1, \cite{sgx-remote-attestation-is-not-sufficient}). At the end of this protocol, the Provisioning enclave will have a private Attestation key unknown to Intel, which can be used in the remote attestation process (see Section \ref{subsec:enclaves-sgx-attestation}).

Whenever an SGX-enabled hardware goes through provisioning, Intel stores a copy of the PPID used and an encrypted version of the Attestation key created. It is encrypted with the Provisioning Seal by the hardware (which only the hardware can decrypt), allowing secure key recovery at a later date (\cite{sgx-extending-sgx-autonomy-and-anonymity-thesis} section 2.4.5.1).\footnote{During secure key recovery, or re-provisioning a new Attestation key (e.g.\ following an SGX implementation update), the hardware must sign a message with the old Attestation key (e.g.\ after obtaining and decrypting the encrypted version) and pass it to Intel (\cite{sgx-extending-sgx-autonomy-and-anonymity-thesis} section 2.4.5.1). This requirement allows Intel to check if the old key was revoked, and prevent re-provisioning requests to hardware that may be compromised \cite{sgx-epid-provisioning-attestation}.}

Attestation keys become `members' of a group public key for the EPID (Enhanced Privacy ID) signature scheme  \cite{epid-paper} after `joining' the group. The EPID Join protocol \cite{epid-paper} requires passing three messages between the group key `issuer' (Intel) and the `platform' (SGX-enabled hardware).\footnote{If Intel already has a copy of the provided PPID, then it will skip the EPID Join protocol and just send back the relevant encrypted Attestation key stored in anticipation of key recovery requests (\cite{sgx-extending-sgx-autonomy-and-anonymity-thesis} section 2.4.5.1). Of course, if the hardware operator intends to re-provision a new key, then the Join protocol will be enacted.}
\begin{enumerate}
    \item The issuer sends their EPID group key material to the platform.\footnote{Unlike Ed25519 curve points, which can be represented with a single value (once compressed), EPID keys (both public and private) are composed of multiple distinct values \cite{epid-paper}.}
    \item The platform generates part of their EPID private key, uses it to manipulate the group key material, and sends that manipulated material back to the issuer as a `challenge'.
    \item The issuer `responds' with further manipulation of that material, which the platform uses to complete their EPID private key. Note that the group key material modifications are only temporary, and don't persist beyond the Join protocol.
\end{enumerate}

The Attestation key (EPID private key) can be used to make signatures, which Intel can validate with the relevant EPID group key. Interestingly, an Attestation key's signatures are detached (as far as Intel knows) from the hardware that provisioned it. This provides increased privacy protections for operators of SGX enclaves (\cite{intel-sgx-explained-advanced} section 5.8.2).\footnote{EPID signatures can be linkable or unlinkable (i.e.\ one signature linkable to another signature), depending on the hardware operator's preference \cite{sgx-epid-provisioning-attestation, kudelski-sgx-secure-enclaves-review}. MobileCoin nodes and Fog service operators currently use\marginnote{sgx/epid- types/src/ quote\_sign.rs {\tt quote\_sign()}} the linkable variant by default \cite{mobilecoin-consensus-service-readme}, which makes it easier to identify and revoke compromised Attestation keys \cite{sgx-epid-provisioning-attestation}. EPID linkability may become mandatory in future versions of MobileCoin, according to private correspondence with MobileCoin developers.} EPID permits the issuer (Intel) to reject attestation signatures produced by compromised group members \cite{epid-paper, sgx-epid-provisioning-attestation}.\footnote{We leave the intricacies of EPID and its revocation mechanism to the paper \cite{epid-paper} where it was first introduced.}

\subsubsection{Pass Attestation key to Quoting enclave}

Since the Attestation key is the linchpin of remote attestation, it should only be accessible by carefully designed enclaves. In fact, only one enclave is intended to use it, namely the Intel-provided Quoting enclave. This enclave is in charge of the remote attestation process (discussed next), and is the second enclave authorized by the Launch enclave to have the {\tt PROVISIONKEY} attribute (Section \ref{subsec:enclaves-sgx-initializing}). To transmit the Attestation key from the Provisioning to the Quoting enclave, it is encrypted with a Provisioning Seal key and stored by the system software for later decryption and use by the Quoting enclave (\cite{intel-sgx-explained-advanced} section 5.8.2).\footnote{It may seem like Attestation keys can only be safely encrypted with the Provisioning Seal key thanks to the {\tt PROVISIONKEY} limitation. However, it is actually the {\tt MRSIGNER} input to Provisioning Seal keys that secures Attestation keys. Only a Quoting enclave produced by the same enclave author as the corresponding Provisioning enclave may decrypt Attestation keys, and only a Provisioning enclave approved by the manufacturer may obtain useful Attestation keys. In this way, the manufacturer can ensure Attestation keys are safely managed throughout their lifetimes.}


\subsection{SGX attestation}
\label{subsec:enclaves-sgx-attestation}

To interact remotely with an enclave, usually the first step is to open a secure communication channel with it. Of course, a channel should only open successfully if the remote enclave is really an enclave. To that end, the key exchange process between remote enclave and would-be user (e.g.\ as part of the TLS \cite{tls-transport-layer-security-resource} or Noise \cite{noise-protocol-framework} communication protocols)\footnote{MobileCoin nodes are designed to use the Noise protocol, as implemented in the {\tt mc-crypto-noise} Rust crate.} should include a proof that the enclave is, in fact, an enclave.

However, the enclave that is setting up a communication channel isn't equipped to create that `attestation' proof by itself. As we have discussed, only the Quoting enclave is able to produce signatures with the Attestation key. Instead, the enclave creates a local {\tt Report} proving to the Quoting enclave it is a secure enclave on the same machine. The {\tt Report} attests to a specific message (i.e.\ a {\tt Report} says ``this message was produced by a legitimate SGX secure enclave").

The Quoting enclave verifies the {\tt Report}, then signs its included message with the Attestation key, producing a so-called {\tt Quote}. This {\tt Quote} can be transmitted to Intel, which uses the relevant EPID group key to verify the attestation signature (or reject it if produced by a revoked signer), then re-signs the message with an Intel RSA key. The Intel-signed message is known as an {\tt Attestation Verification Report}, and gets sent back to the enclave operator, who can forward it to the original communication partner. That partner verifies the Intel signature and uses the message contents to complete the communication channel set-up.

Once a channel is established, there is no need for further attestation. Moreover, enclaves only need one public key to set up a communication channel with arbitrary numbers of users. An enclave can produce a single {\tt Attestation Verification Report} containing that public key, and store it indefinitely in anticipation of requests from users who want to communicate with the enclave.

\subsubsection{SGX local attestation}

Attestation between enclaves on the same machine relies on the {\tt EREPORT} SGX CPU instruction (\cite{intel-sgx-explained-advanced} section 5.8.1). This instruction takes as input a message to report on ({\tt REPORTDATA}), and the {\tt MRENCLAVE} and attributes of the target enclave (the enclave being reported to). It outputs a {\tt Report}. If used in the context of remote attestation, the target will be the Quoting enclave.

Internally, {\tt EREPORT} makes a Report key on behalf of the target enclave (using its measurement and attributes instead of the calling enclave's values; recall Section \ref{subsec:enclaves-sgx-keys}). The Report key is used as the cipher key to an AES-CMAC algorithm, which basically outputs a hash (called a {\tt MAC}) of inputs that is dependent on the cipher key (similar to how the {\tt EINIT token} is constructed).

The AES-CMAC inputs are identifying details about the reporting enclave (obtained directly from its {\tt SECS}), and the {\tt Report}'s message. When a target enclave receives a {\tt Report}, it can use {\tt EGETKEY} to recreate the Report key, then recompute the {\tt MAC} to verify the {\tt Report}'s stored value. If the {\tt MAC}s match, then the {\tt Report}'s message must have been produced by an enclave (specifically, the enclave represented by the hashed information) on the same machine as the target enclave.\footnote{Only the {\tt EREPORT} SGX CPU instruction is able to make Report keys on behalf of another enclave. This means the target enclave can be sure a valid {\tt Report} was definitely made by a secure enclave, as only secure enclaves may invoke {\tt EREPORT}.}

Table \ref{table:ereport-contents} itemizes the content of a {\tt Report} (see \cite{intel-sgx-explained-advanced} section 5.8.1, or \cite{sgx-attestation-service-api} section 4.3.1).

\begin{tabularx}{\textwidth}{|l|X|}
\caption{{\tt Report} Contents}
\label{table:ereport-contents}\\
\hline
    Fields & Description \\
\hline\hline
    {\tt MAC} & The output of an AES-CMAC algorithm (more-or-less a hash of inputs), with the Report key as cipher key. All other fields in the {\tt Report} (aside from the {\tt KEYID}) are inputs to the algorithm. \\
\hline
    {\tt ATTRIBUTES} & Attributes of the enclave that called {\tt EREPORT}.  \\
\hline
    {\tt MRENCLAVE} & Measurement of the enclave that called {\tt EREPORT} (Section \ref{subsec:enclaves-sgx-measurements}). \\
\hline
    {\tt MRSIGNER} & Hash of the public key used to sign the enclave that called {\tt EREPORT} (Section \ref{subsec:enclaves-sgx-measurements}). \\
\hline
    {\tt ISVPRODID} & Product ID of the enclave that called {\tt EREPORT}. \\
\hline
    {\tt ISVSVN} & Security version number of the enclave that called {\tt EREPORT}. \\
\hline
    {\tt CPUSVN} & Current security version number (SVN) of the SGX implementation.\footnote{Unlike other SGX key variants which take the {\tt CPUSVN} as an input (Table \ref{table:sgx-key-derivation-material}), Report keys are generated (by both {\tt EREPORT} and {\tt EGETKEY}) using the current SGX implementation's security version. Doing so ensures outstanding {\tt Report}s become worthless after every SGX implementation security update (\cite{intel-sgx-explained-advanced} section 5.8.1).} \\
\hline
    {\tt REPORTDATA} & Message provided as an input to {\tt EREPORT}. \\
\hline
    {\tt KEYID} & A random number used to make the Report key unique. Allows the Report key to be recreated, but does not otherwise contribute to making the {\tt MAC}. \\
\hline
\end{tabularx}

\subsubsection{SGX remote attestation}

After the Quoting enclave receives a {\tt Report} containing a message intended for remote attestation (and validates it), there is not much left to say \cite{sgx-attestation-service-api}.

\begin{enumerate}
    \item The Quoting enclave replaces the {\tt Report}'s {\tt MAC} with an EPID signature using the Attestation key (\cite{intel-sgx-explained-advanced} section 5.8.2), transforming it into a {\tt Quote}.
    \item The {\tt Quote} is sent to Intel's Attestation Service (IAS), which verifies the EPID signature and checks if the signer was revoked.\footnote{\label{footnote:enclaves-revoke-epid-groups-hard-fork-force-update}Intel can periodically revoke entire EPID groups in parallel with an SGX security update (inferred from the `isvEnclaveQuoteStatus::GROUP\_REVOKED' status that can be returned in {\tt AVR} requests \cite{sgx-attestation-service-api}). This forces all members of that group to re-provision new Attestation keys if they want to obtain new {\tt AVR}s. Forced re-provisioning prevents Attestation keys that were exposed to potentially insecure SGX implementations from being used to sign {\tt Quote}s with new {\tt CPUSVN}s. This incidentally provides a convenient mechanism for enforcing SGX security updates in MobileCoin. If Intel issues an SGX update that triggers re-provisioning on new attestation requests, then MobileCoin can hard fork (author a new validator enclave with new {\tt MRENCLAVE}) to force nodes to update their SGX implementations. Nodes contain enclaves that securely send encrypted transactions to each other, but the enclaves can only peer with enclaves that have the same\marginnote{*crypto/ake/ enclave/src/ lib.rs {\tt get\_verif- ier()}} {\tt MRENCLAVE} value (based on the {\tt AVR}s they receive from those nodes). Since these {\tt AVR}s can only be made after the new enclave is released, if the enclave is released after a re-provisioning-inducing update, the {\tt AVR}s must contain {\tt CPUSVN} values that are considered secure by Intel. Without hard forking in this way, nodes can store old {\tt AVR}s made for old SGX implementations and continue using them to establish communication channels with other enclaves and users even when Intel would force a re-provisioning if the nodes were to obtain new {\tt AVR}s.} Intel re-signs the {\tt Quote} with an Intel RSA key, transforming it into an {\tt Attestation Verification Report} ({\tt AVR}) \cite{sgx-attestation-service-api}.
    \item The {\tt AVR} is sent back to the enclave operator, who may forward it to a desired enclave user.
    \item The user verifies\marginnote{attest/core/ src/ias/ verify.rs {\tt Verifica- tionReport ::verify()}} the {\tt AVR} signature and checks that the signing public key belongs to Intel.\footnote{In reality, {\tt Attestation Verification Report}s include a certificate signing chain\marginnote{attest/core/ src/ias/ verify.rs {\tt Verifica- tionReport ::verify\_ signature()}}, which extends from the signing key to a root `Attestation Report Signing CA Certificate' that should be trusted by the user. \cite{sgx-attestation-service-api}} If the {\tt AVR}'s contents (measurements, attributes, etc.) meet the user's expectations, they can continue communicating with the enclave.
\end{enumerate}




