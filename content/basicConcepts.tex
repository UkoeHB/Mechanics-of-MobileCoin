\chapter{Basic Concepts}
\label{chapter:basicConcepts}



%----------NOTATION
\section{A few words about notation}

A focal objective of this report was to collect, review, correct, and homogenize all existing information concerning the inner workings of the MobileCoin cryptocurrency, and, at the same time, supply all the necessary details to present the material in a constructive and single-threaded manner.

An important instrument to achieve this was to settle for a number of notational conventions. Among others, we have used:

\begin{itemize}
    \item lower case letters to denote simple values, integers, strings, bit representations, etc.,
    \item upper case letters to denote curve points and complicated constructs.
\end{itemize}

For items with a special meaning, we have tried to use as much as possible the same symbols throughout the document. For instance, a curve generator is always denoted by \(G\), its order is \(l\), private/public keys are denoted whenever possible by \(k/K\) respectively, etc.
\\

Beyond that, we have aimed at being {\em conceptual} in our presentation of algorithms and schemes. A reader with a computer science background may feel we have neglected questions like the bit representation of items, or, in some cases, how to carry out concrete operations. Moreover, students of mathematics may find we disregarded explanations of abstract algebra.

However, we don’t see this as a loss. A simple object such as an integer or a string can always be represented by a bit string. So-called `endianness' is rarely relevant, and is mostly a matter of convention for our algorithms.\footnote{In computer memory, each byte is stored in its own address (an address is akin to a numbered slot, which a byte can be stored in). A given `word' or variable is referenced by the lowest address of its bytes. If variable $x$ has 4 bytes, stored in addresses 10-13, address 10 is used to find $x$. The way bytes of $x$ are organized in its set of addresses depends on {\em endianness}, although each individual byte is always and everywhere stored the same way within its address. Basically, which end of $x$ is stored in the reference address? It could be the {\em big end} or {\em little end}. Given $x = $ 0x12345678 (hexadecimal; 2 hexadecimal digits occupy 1 byte e.g.\ 8 binary digits a.k.a.\ bits), and an array of addresses \{10, 11, 12, 13\}, the big endian encoding of $x$ is \{12, 34, 56, 78\} and the little endian encoding is \{78, 56, 34, 12\}. \cite{endianness}}

Elliptic curve points are normally denoted by pairs \((x, y)\), and can therefore be represented with two integers. However, in the world of cryptography, it is common to apply {\em point compression} techniques that allow a point to be represented using only the space of one coordinate. For our conceptual approach, it is often accessory whether point compression is used or not, but most of the time it is implicitly assumed.\\

We\marginnote{[blake2] src/ blake2b.rs} have also used cryptographic hash functions freely without specifying any concrete algorithms. In the case of MobileCoin, it will typically be BLAKE2b\footnote{The BLAKE2 hashing algorithm is a successor to the NIST standard {\em SHA-3} \cite{nist-sha3} finalist BLAKE. The BLAKE2b variant is optimized for 64-bit platforms. \cite{blake2-paper}}, but if not explicitly mentioned then it is not important to the theory. 

A cryptographic hash function (henceforth simply `hash function' or `hash') takes in some message $\mathfrak{m}$ of arbitrary length and returns a hash $h$ (or `message digest') of fixed length, with each possible output equiprobable for a given input. Cryptographic hash functions are difficult to reverse (called preimage resistance), have an interesting feature known as the {\em large avalanche effect} that can cause very similar messages to produce very dissimilar hashes, and it is hard to find two messages with the same message digest.

Hash functions will be applied to integers, strings, curve points, or combinations of these objects. These occurrences should be interpreted as hashes of bit representations, or the concatenation of such representations. Depending on context, the result of a hash will be numeric, a bit string, or even a curve point. Further details in this respect will be given as needed.



%----------MODULAR ARITHMETIC
\section{Modular arithmetic}
\label{sec:modular-arithmetic}

Most modern cryptography begins with modular arithmetic, which in turn begins with the modulus operation (denoted `mod'). We only care about the positive modulus, which always returns a positive integer.

The positive modulus is similar to the `remainder' after dividing two numbers, e.g.\ $c$ the `remainder' of $a/n$. Let's imagine a number line. To calculate $c = a \pmod n$, we stand at point $a$, then walk toward zero with each $\text{step} = n$ until we reach an integer $\geq{0}$ and $< n$. That is $c$. For example, $4$ (modulo 3) $= 1$, $-5 \pmod 4 = 3$, and so on.

Formally, the positive modulus is here defined for $c = a \pmod n$ as $a = n x + c$, where $0\leq{c}<{n}$ and $x$ is a signed integer that gets discarded ($n$ is a positive non-zero integer).

Note that, if $a \leq n$, $-a \pmod n$ is the same as $n - a$.


\subsection{Modular addition and multiplication}
\label{subsec:modular-addition-multiplication}

In computer science, it is important to avoid large numbers when doing modular arithmetic. For example, if we have $29+87 \pmod{99}$ and we aren't allowed variables with three or more digits (such as $116 = 29+87$), then we can't compute $116 \pmod{99} = 17$ directly.

To perform $c = a+b \pmod n$, where $a$ and $b$ are each less than the modulus $n$, we can do this:
\begin{itemize}
	\item Compute $x = n-a$. If $x > b$ then $c = a+b$, otherwise $c = b - x$.
\end{itemize}

We can use modular addition to achieve modular multiplication ($a*b \pmod n = c$) with an algorithm called `double-and-add'. Let us demonstrate by example. Say we want to do $7*8 \pmod 9 = 2$. It is the same as 
\[7*8 = 8+8+8+8+8+8+8 \pmod 9\]

Now break this into groups of two:
\[(8+8) + (8+8) + (8+8) + 8\]

And again, by groups of two:
\[[(8+8) + (8+8)] + (8+8) + 8\]

The total number of $+$ point operations falls from 6 to 4 because we only need to find $(8+8)$ once.\footnote{The effect of double-and-add becomes apparent with large numbers. For example, with $2^{15} * 2^{30}$ straight addition would require about $2^{15}$ $+$ operations, while double-and-add only requires 15!}\\

Double-and-add is implemented by converting the first number (the `multiplicand' $a$) to binary (in our example, 7 $\rightarrow$ [0111]), then going through the binary array and doubling and adding. Essentially, we are converting $7*8 \pmod{9}$ into\vspace{.155cm}
\begin{align*}
    &1*2^0*8 + 1*2^1*8 + 1*2^2*8 + 0*2^3*8\\
    &= 8 + 16 + 32 + 0*64
\end{align*}

Let's make an array $A = [0111]$ and index it 3,2,1,0.\footnote{This is known as `LSB 0' numbering, since the least significant bit has index 0. We will use `LSB 0' for the rest of this chapter. The point here is clarity, not accurate conventions.} A[0] = 1 is the first element of A and is the least significant bit. We set a result variable to be initially $r = 0$, and set a sum variable to be initially $s = 8$ (more generally, we start with $s = b$). We follow this algorithm:
\begin{enumerate}
	\item Iterate through: $i = (0,...,A_{size} - 1)$
	\begin{enumerate}
		\item If A[i] $\stackrel{?}{=}$ 1, then $r = r + s \pmod n$.
		\item Compute $s = s + s \pmod n$.
	\end{enumerate}
	\item Use the final $r$: $c = r$.
\end{enumerate}

In our example $7*8 \pmod 9$, this sequence appears:
\begin{enumerate}
	\item $i = 0$
	\begin{enumerate}
		\item A[0] = 1, so $r = 0 + 8 \pmod 9$ = 8
		\item $s = 8 + 8 \pmod 9$ = 7
	\end{enumerate}
	\item $i = 1$
	\begin{enumerate}
		\item A[1] = 1, so $r = 8 + 7 \pmod 9$ = 6
		\item $s = 7 + 7 \pmod 9$ = 5
	\end{enumerate}
	\item $i = 2$
	\begin{enumerate}
		\item A[2] = 1, so $r = 6 + 5 \pmod 9$ = 2
		\item $s = 5 + 5 \pmod 9$ = 1
	\end{enumerate}
	\item $i = 3$
	\begin{enumerate}
		\item A[3] = 0, so $r$ stays the same
		\item $s = 1 + 1 \pmod 9$ = 2
	\end{enumerate}
	\item $r = 2$ is the result.
\end{enumerate}


\subsection{Modular exponentiation}
\label{subsec:modular-exponentiation}

Clearly $8^7 \pmod 9 = 8*8*8*8*8*8*8 \pmod 9$. Just like double-and-add, we can do `square-and-multiply'. For $a^e \pmod{n}$:
\begin{enumerate}
	\item Define $e_{scalar} \rightarrow e_{binary}$; $A = [e_{binary}]$; $r = 1$; $m = a$
	\item Iterate through: $i = (0,...,A_{size} - 1)$
	\begin{enumerate}
		\item If A[i] $\stackrel{?}{=}$ 1, then $r = r * m \pmod n$.
		\item Compute $m = m * m \pmod n$.
	\end{enumerate}
	\item Use the final $r$ as result.
\end{enumerate}


\subsection{Modular multiplicative inverse}
\label{subsec:modular-multiplicative-inverse}

Sometimes we need $1/a \pmod n$, or in other words $a^{-1} \pmod n$. The inverse of something times itself is by definition one (identity). Imagine $0.25 = 1/4$, and then $0.25*4 = 1$.\\

In modular arithmetic, for $c = a^{-1} \pmod{n}$, $a c \equiv 1 \pmod{n}$ for $0 \leq c < n$ and for $a$ and $n$ relatively prime \cite{shoup-modular-multiplicative-inverse}.\footnote{In the equation $a \equiv b \pmod{n}$, $a$ is {\em congruent} to $b \pmod{n}$, which just means \(a \pmod{n} = b \pmod{n}\).} Relatively prime means they don't share any divisors except 1 (the fraction $a/n$ can't be reduced/simplified).

We can use square-and-multiply to compute the modular multiplicative inverse when $n$ is a prime number because of {\em Fermat's little theorem} \cite{fermats-little-theorem}:\vspace{.175cm}
\begin{align*} 
    a^{n-1} &\equiv 1 \pmod{n} \\
    a*a^{n-2} &\equiv 1 \pmod{n} \\
    c \equiv a^{n-2} &\equiv a^{-1} \pmod{n}
\end{align*}

More generally (and more rapidly), the so-called `extended Euclidean algorithm' \cite{extended-euclidean-algorithm} can also find modular inverses.


\subsection{Modular equations}
\label{subsec:modular-equations}

Suppose we have an equation $c = 3*4*5 \pmod 9$. Computing this is straightforward. Given some operation $\circ$ (for example, $\circ = *$) between two expressions $A$ and $B$:\vspace{.175cm}
\[(A \circ B)\pmod{n} = {[A\pmod {n}] \circ [B\pmod{n}]}\pmod{n}\]

In our example, we set $A = 3*4$, $B = 5$, and $n = 9$:\vspace{.175cm}
\begin{align*}
(3*4 * 5) \pmod{9} &= {[3*4 \pmod {9}] * [5 \pmod{9}]} \pmod{9} \\
				   &= [3]*[5] \pmod 9 \\
				 c &= 6
\end{align*}

Now we have a way to do modular subtraction (which, as we will see, is not a standalone operation defined for finite fields).\vspace{.175cm}
\begin{align*}
A - B \pmod n &\rightarrow A + (-B) \pmod n \\
			  &\rightarrow {[A \pmod {n}] + [-B \pmod{n}]} \pmod{n}
\end{align*}

The same principle would apply to something like $x = (a-b*c*d)^{-1} (e*f+g^{h}) \pmod n$.\footnote{The modulus of large numbers can exploit modular equations. For example, we can write $254 \pmod {13} \equiv 2*10*10 + 5*10 + 4 \equiv (((2)*10 + 5)*10 + 4) \pmod {13}$. An algorithm for $a \pmod n$ when $a > n$ is:
\begin{enumerate}
	\item Define $A \rightarrow [a_{decimal}]$; $r = 0$
	\item For $i = A_{size} - 1,...,0$
	\begin{enumerate}
		\item $r = (r*10 + A[i]) \pmod n$
	\end{enumerate}
	\item Use the final $r$ as result.
\end{enumerate}}



%----------ELLIPTIC CURVE CRYPTOGRAPHY
\section{Elliptic curve cryptography}
\label{sec:EllipticCurveCryptography}


\subsection{What are elliptic curves?}
\label{subsec:elliptic_curves_section}

A\marginnote{[dalek25519] src/back- end/serial/
[u32$|$u64]/ field.rs} finite field \(\mathbb{F}_q\), where \(q\) is a prime number greater than 3, is the field formed by the set \(\{0, 1, 2, ..., q-1\}\). Addition and multiplication \((+,  \cdot)\) and negation $(-)$ are calculated\( \pmod q\).

``Calculated\( \pmod q\)" means\( \pmod q\) is performed on any instance of an arithmetic operation between two field elements, or negation of a single field element. For example, given a prime field \(\mathbb{F}_p\) with $p = 29$, $17+20=8$ because $37 \pmod{29} = 8$. Also, $-13 = -13 \pmod{29} = 16$.\\

Typically, an elliptic curve is defined as the set of all points with coordinates \((x, y)\) satisfying a {\em Weierstraß} equation \cite{Hankerson:2003:GEC:940321} (for a given $(a,b)$ pair):\footnote{\label{notation1}Notation: The phrase $a \in \mathbb{F}$ means $a$ is some element in the field $\mathbb{F}$.}\vspace{.175cm}
\[y^2 = x^3 + a x + b \quad \textrm{where} \quad a, b, x, y \in \mathbb{F}_q\]

The cryptocurrency MobileCoin uses a special curve belonging to the category of so-called {\em twisted Edwards} curves \cite{Bernstein2008-twisted-edwards}, which are commonly expressed as (for a given $(a,d)$ pair):\vspace{.175cm}
\[a x^2 + y^2 = 1 + d x^2 y^2 \quad \textrm{where} \quad a, d, x, y \in \mathbb{F}_q \]

In what follows, we will prefer this second form. The advantage it offers over the previously mentioned Weierstraß form is that basic cryptographic primitives require fewer arithmetic operations, resulting in faster cryptographic algorithms (see Bernstein {\em et al.} in \cite{Bernstein2007-faster-ec-ops} for details).\\

Let \(P_1 = (x_1, y_1)\) and \(P_2 = (x_2, y_2)\) be two points belonging to a twisted Edwards elliptic curve (henceforth known simply as an EC). We define addition on points by defining $P_1 + P_2 = (x_1, y_1) + (x_2, y_2)$ as the point $P_3 = (x_3, y_3)$ where\footnote{Typically elliptic curve points are converted into projective coordinates (or a similar representation, e.g.\ extended twisted Edwards coordinates \cite{twisted-edwards-revisited}) prior to curve operations like point addition, in order to avoid performing field inversions for efficiency. \cite{ecc-projective}}\vspace{.175cm}
\begin{align*}
x_3 & =  \frac{x_1 y_2 + y_1 x_ 2}{1 + d x_1 x_2 y_1 y_2}  \pmod{q} \\
y_3 & =  \frac{y_1 y_2 - a x_1 x_2}{1 - d x_1 x_2 y_1 y_2} \pmod{q} 
\end{align*}

These formulas for addition also apply to point doubling; that is, when  \(P_1 = P_2\). To subtract a point, invert its coordinates over the y-axis, $(x,y) \rightarrow (-x,y)$ \cite{Bernstein2008-twisted-edwards}, and use normal point addition. Recall that `negative' elements $-x$ of $\mathbb{F}_q$ are really $-x \pmod{q}$.
\\

Whenever two curve points are added together, $P_3$ is a point on the `original' elliptic curve, or in other words all $x_3,y_3 \in \mathbb{F}_q$ and satisfy the EC equation.


\subsection{Group theory}
\label{subsec:group-theory}

Importantly, elliptic curves have what is known as an {\em abelian group} structure \cite{abelian-group}. Every curve has a so-called `point-at-infinity' $I$, which is like a `zero position' on the curve (its coordinates are $(0, 1)$), and a finite number of points $N$ that can be computed. Any point $P$ added with itself $N$ times will produce the point-at-infinity $I$, and $I + P = P$.

\subsubsection{Group theory: Intro}

For now, let's step back from elliptic curves and imagine a clock-like ring with {\em order} $N$.\footnote{The basics of group theory are very important to grasp for the rest of this document. Visual learners may find it helpful to draw pictures and work out what is happening by hand.} The zeroth position $0$ (or $I$) is at the top, followed by $1$ and preceded by $N-1$. Clearly, we can walk around the ring with step-size $1$, and reach the top again after $N$ steps.

While it's useful to think of ourselves as walking around the circle, it's much more accurate to think about each position on the circle as being a `point', and taking steps is like `adding points together'. If we stand at point $P_2$ on a circle with $N = 6$, then with each `step' we are adding $P_2$ to the point we are currently standing on.\vspace{.115cm}
\begin{align*}
    I + P_2 &= P_2 \\
    P_2 + P_2 &= P_4 \\
    P_4 + P_2 &= P_6 = I
\end{align*}

Note how we landed back on our starting position after three steps. The point $P_2$ has generated a {\em cyclic} subgroup with order 3 out of multiples of itself. It's cyclic because after a while you always get back to where you started. It's a subgroup since it doesn't (necessarily) contain all the points on the circle.

The order of any point is equal to the number of points in the subgroup it can generate. If a point's order is prime, then all the other (non-point-at-infinity) points it generates will generate the same subgroup. In our previous example, where the subgroup's order was 3, the point $P_4$ also generates the same subgroup.
\begin{align*}
    I + P_4 &= P_4 \\
    P_4 + P_4 &= P_2 \\
    P_2 + P_4 &= P_6 = I
\end{align*}

However, $P_1$ has order 6 which is not prime, so not all of the points it generates have order 6 (only $P_5$ will generate the same subgroup).

\subsubsection{Group theory: Useful concepts}

We always land somewhere on the ring no matter how many multiples of a point we add together. This lets us simplify scalar multiplication from $nP$ to $[n \pmod u] P$, where $u$ is the order of the point $P$. A point can't actually be multiplied by 0, so if $n \pmod u \stackrel{?}{=} 0$ just multiply $P$ by $u$ or return the 0\nth position directly ($I$). The orders of all possible subgroups are divisors of $N$ (by {\em Lagrange’s theorem} \cite{lagranges-theorem}).

To find the order, $u$, of any given point $P$'s subgroup:
\begin{enumerate}
    \item Find $N$ (e.g.\ use {\em Schoof's algorithm} \cite{schoofs-algorithm}).
    \item Find all the divisors of $N$.
    \item For every divisor $n$ of $N$, compute $n P$.
    \item The smallest $n$ such that $n P \stackrel{?}{=} I$ is the order $u$ of the subgroup.
\end{enumerate} 

Suppose we are given two points $P_a, P_b$ and are told they both have order $u$. Do they necessarily belong to the same subgroup, or might there be more than one subgroup with order $u$?

We can think of the two points in terms of $P_1$ which has order $N$, such that $P_a = n_a*P_1$ and $P_b = n_b*P_1$. We know that $N*P_1 = I$, and that $u*P_a = u*P_b = I$. Therefore $u*n_a$ and $u*n_b$ must be multiples of $N$.

Since $u$ is a divisor of $N$ (recalling Lagrange's theorem), for $u*n_a$ and $u*n_b$ to be multiples of $N$, scalars $n_a, n_b$ must have a common denominator that is another divisor of $N$, namely $e = N/u$. Therefore $P_a = (n_a/e)*e*P_1$ and $P_b = (n_b/e)*e*P_1$, or in other words $P_a$ and $P_b$ are multiples of the same point $e*P_1$ and must both be members of that point's subgroup.

Put simply, any two points $P_a$ and $P_b$ with order $u$ are in the same subgroup, which is composed of multiples of $(N/u)* P_1$. Furthermore, for any random point $P' = n'*P_1$, the expression $(N/u)*P'$ will either be a point in the $u$ subgroup (since $n'*(N/u)*P_1$ is a multiple of $(N/u)*P_1$), or $I$ (in which case $n'$ must be a multiple of $u$, so $P'$ is a member of the $e = (N/u)$ subgroup).

\subsubsection{Group theory: Back to elliptic curves}

Elliptic curve points have no concept of `proximity', so for our clock-like example with $N = 6$, $P_3$ is no `closer' or `farther' from $I$ than $P_1$. However, to connect the analogy we can `map' curve points onto the ring. Take any point $P_w$ with order $N$ and put it at position 1, then construct the ring out of multiples of $P_w$. All of the observations we have made so far still hold, and will hold even if the mapping is redone with a different point $P_z$ that also has order $N$.

ECs\marginnote{[dalek25519] src/back- end/serial/
curve\_ models/ mod.rs} selected for cryptography typically have $N = hl$, where $l$ is some sufficiently large (such as 160 bits) prime number and $h$ is the so-called {\em cofactor} which could be as small as 1 or 2.\footnote{EC with small cofactors allow relatively faster point addition, etc. \cite{Bernstein2008-twisted-edwards}.} One point in the subgroup of size $l$ is usually selected to be the generator $G$ as a convention. For every other point $P$ in that subgroup, there exists an integer $0 < n \leq l$ satisfying $P = n G$.

Based on our understanding from the previous section, we can use the following algorithm to find (non-point-at-infinity) points in the subgroup of order $l$:
\begin{enumerate}
    \item Find $N$ of the elliptic curve EC, choose subgroup order $l$, compute $h = N/l$.
    \item Choose a random point $P'$ in EC.
    \item Compute $P=h P'$.
    \item If $P \stackrel{?}{=} I$, return to step 2; otherwise, $P$ is in the subgroup of order $l$.
\end{enumerate}

Calculating the scalar\marginnote{[dalek25519] src/back- end/serial/
[u32$|$u64]/ scalar.rs} product between any integer $n$ and any point $P$, $nP$, is not difficult, whereas finding $n$ such that $P_1 = n P_2$ is thought to be computationally hard. By analogy to modular arithmetic, this is often called the {\em discrete logarithm problem} (DLP).\footnote{In modular arithmetic, finding the discrete log of $h$ with respect to $g$, $x$, such that $g^x = h$, is thought to be difficult for some group orders. \cite{network-security-crash-course-dlp}} Scalar multiplication can be seen as a {\em one-way function}, which paves the way for using elliptic curves for cryptography.\footnote{No known equation or algorithm can efficiently (based on available technology) solve for $n$ in $P_1 = n P_2$, meaning it would take many, many years to unravel just one scalar product.}

The scalar product $nP$ is equivalent to $(((P+P)+(P+P))...)$. Though not always the most efficient approach, we can use double-and-add like in Section \ref{subsec:modular-addition-multiplication}. To get the sum $R = n P$, remember we use the $+$ point operation discussed in Section \ref{subsec:elliptic_curves_section}.

\begin{enumerate}
	\item Define $n_{scalar} \rightarrow n_{binary}$; $A = [n_{binary}]$; $R = I$, the point-at-infinity; $S = P$
	\item Iterate through: $i = (0,...,A_{size} - 1)$
	\begin{enumerate}
		\item If A[i] $\stackrel{?}{=}$ 1, then R += S.
		\item Compute S += S.
	\end{enumerate}
	\item Use the final R as result.
\end{enumerate}

Note that EC scalars for points in the subgroup of size $l$ (which we will be using henceforth) are members of the finite field $\mathbb{F}_l$. This means arithmetic operations between scalars are mod $l$.


\subsection{Public key cryptography with elliptic curves}
\label{subsec:ec-keys}
Public key cryptography algorithms can be devised in a way analogous to modular arithmetic.

Let \(k\) be a randomly selected number satisfying \(0 < k < l\), and call it a {\em private key}.\footnote{The private key is sometimes known as a {\em secret key}. This lets us abbreviate: pk = public key, sk = secret key.} Calculate the corresponding {\em public key} \(K\) (an EC point) with the scalar product \(k G = K\). 

Due to the {\em discrete logarithm problem} (DLP), we cannot easily deduce \(k\) from \(K\) alone. This property allows us to use the values \((k, K)\) in standard public key cryptography algorithms.


\subsection{Diffie-Hellman key exchange with elliptic curves}
\label{DH_exchange_section}

A basic {\em Diffie-Hellman} \cite{Diffie-Hellman} exchange of a shared secret between {\em Alice} and {\em Bob} could take place in the following manner:

\begin{enumerate}
	\item Alice and Bob generate their own private/public keys \((k_A, K_A) \textrm{ and } (k_B, K_B)\). Both publish or exchange their public keys, and keep the private keys for themselves.

	\item Clearly, it holds that \[S = k_A K_B = k_A k_B G = k_B k_A G = k_B K_A\]

	Alice could privately calculate \(S = k_A K_B\), and Bob \(S = k_B K_A\), allowing them to use this single value as a shared secret.

	For example, if Alice has a message $m$ to send Bob, she could hash the shared secret \(h = \mathcal{H}(S)\), compute $x = m + h$, and send $x$ to Bob. Bob computes $h' = \mathcal{H}(S)$, calculates $m = x - h'$, and learns $m$.
\end{enumerate}   

An external observer would not be able to easily calculate the shared secret due to the `Diffie-Hellman Problem' (DHP), which says finding $S$ from $K_A$ and $K_B$ is very difficult. Also, the DLP prevents them from finding $k_A$ or $k_B$.\footnote{The DHP is thought to be of at least similar difficulty to the DLP, although it has not been proven. \cite{galbraith-diffie-hellman-problem}}


\subsection{Schnorr signatures and the Fiat-Shamir transform}
\label{sec:schnorr-fiat-shamir}

In 1989, Claus-Peter Schnorr published a now-famous interactive authentication protocol \cite{schnorr-signatures}, generalized by Maurer in 2009 \cite{simple-zk-proof-maurer}, that allows someone to prove they know the private key $k$ of a given public key $K$ without revealing any information about it \cite{Signatures2015BorromeanRS}. It goes something like this:
\begin{enumerate}
	\item The prover generates a random integer \(\alpha \in_R \mathbb{Z}_l\),\footnote{\label{notation3_note}Notation: The $R$ in \(\alpha \in_R \mathbb{Z}_l\) means $\alpha$ is randomly selected from \(\{1,2,3,...,l-1\}\).\marginnote{[dalek25519] src/scalar.rs {\tt Scalar::ran- dom()}} In other words, $\mathbb{Z}_l$ is all integers$\pmod l$. We exclude `$l$' since the point-at-infinity is not useful here.} computes $\alpha G$, and sends $\alpha G$ to the verifier.
	\item The verifier generates a random {\em challenge} $c \in_R \mathbb{Z}_l$ and sends $c$ to the prover.
	\item The prover computes the {\em response} $r = \alpha + c*k$ and sends $r$ to the verifier.
	\item The verifier computes $R = r G$ and $R' = \alpha G + c*K$, and checks $R \stackrel{?}{=} R'$.
\end{enumerate}

The verifier can compute $R' = \alpha G + c*K$ before the prover, so providing $c$ is like saying, ``I challenge you to respond with the discrete logarithm of $R'$." A challenge the prover can only overcome by knowing $k$ (except with negligible probability).

If $\alpha$ was chosen randomly by the prover, then $r$ is randomly distributed \cite{SCOZZAFAVA1993313} and $k$ is information-theoretically secure within $r$ (it can still be found by solving the DLP for $K$ or $\alpha G$).\footnote{\label{information_theoretic_note}A cryptosystem with information-theoretic security is one where even an adversary with infinite computing power could not break it, because they simply wouldn't have enough information.} However, if the prover reuses $\alpha$ to prove his knowledge of $k$, anyone who knows both challenges in $r = \alpha + c*k$ and $r' = \alpha + c'*k$ can compute $k$ (two equations, two unknowns).\footnote{If the prover is a computer, you could imagine someone `cloning'/copying the computer after it generates $\alpha$, then presenting each copy with a different challenge.}\vspace{.175cm}%In security proofs, phrases like `forking lemma' and `rewind on success' are analagous to this cloning attack. See for example \cite{Liu2004}.
\[k = \frac{r-r'}{c-c'}\]

If the prover knew $c$ from the beginning (e.g.\ if the verifier secretly gave it to her), she could generate a random response $r$ and compute $\alpha G = r G - c K$. When she later sends $r$ to the verifier, she `proves' knowledge of $k$ without ever having to know it. Someone observing the transcript of events between prover and verifier would be none the wiser. The scheme is not {\em publicly verifiable}.~\cite{Signatures2015BorromeanRS}\\

In his role as challenger, the verifier spits out a random number after receiving $\alpha G$, making him equivalent to a {\em random function}. Random functions, such as hash functions, are known as random oracles because computing one is like requesting a random number from someone \cite{Signatures2015BorromeanRS}.\footnote{More generally, ``[i]n cryptography... an oracle is any system which can give some extra information on a system, which otherwise would not be available."~\cite{cryptographic-oracle}}\\

Using a hash function, instead of the verifier, to generate challenges is known as a {\em Fiat-Shamir transform} \cite{fiat-shamir-transform}, because it makes an interactive proof non-interactive and publicly verifiable \cite{Signatures2015BorromeanRS}.\footnote{The output of a cryptographic hash function $\mathcal{H}$ is uniformly distributed across the range of possible outputs. That is to say, for some input $A$, $\mathcal{H}(A) \in^D_R \mathbb{S}_H$ where $\mathbb{S}_H$ is the set of possible outputs from $\mathcal{H}$. We use $\in^D_R$ to indicate the function is deterministically random. $\mathcal{H}(A)$ produces the same thing every time, but its output is equivalent to a random number.
}\footnote{Note that non-interactive Schnorr-like proofs (and signatures) require either use of a fixed generator $G$, or inclusion of the generator in the challenge hash. Including it that way is known as key prefixing, which we discuss more later (Section \ref{sec:blsag}).}%[[[ and \ref{sec:robust-key-aggregation}]]] add when multisig added

\subsubsection*{Non-interactive proof}

\begin{enumerate}
	\item Generate random number $\alpha \in_R \mathbb{Z}_l$, and compute $\alpha G$.
	\item Calculate the challenge using a cryptographically secure hash function, \(c = \mathcal{H}(T_p, [\alpha G])\).\footnote{MobileCoin has a policy\marginnote{[MC-tx] src/domain\_ separators.rs} of `domain separating' \cite{domain-separation-context-labels} different uses of hash functions. This in practice means prefixing each `use case' of a hash function with a unique bit-string. We model it here with the tag $T_p$, which might be the text string ``simple Schnorr proof". Domain separated hash functions have different outputs even with the same inputs. For the remainder of this document, we leave out domain separation tags for succinctness. In most cases, uses of hash function can be assumed to have their own tag, but readers seeking precision should refer to the source code.}
	\item Define the response $r = \alpha + c*k$.
	\item Publish the proof pair $(\alpha G, r)$.
\end{enumerate}

\subsubsection*{Verification}

\begin{enumerate}
	\item Calculate the challenge: \(c' = \mathcal{H}(T_p, [\alpha G])\).
	\item Compute $R = r G$ and $R' = \alpha G + c'*K$.
	\item If $R = R'$, then the prover must know $k$ (except with negligible probability).
\end{enumerate}

\subsubsection*{Why it works}

\begin{align*}
r G &= (\alpha + c*k) G \\
	&= (\alpha G) + (c*k G) \\
	&= \alpha G + c*K \\
  R &= R'
\end{align*}

An important part of any proof/signature scheme is the resources required to verify them. This includes space to store proofs and time spent verifying. In this scheme we store one EC point and one integer, and need to know the public key --- another EC point. Since hash functions are comparatively fast to compute, keep in mind that verification time is mostly a function of elliptic curve operations\marginnote{[dalek25519] src/edw- ards.rs}.


\subsection{Signing messages}
\label{sec:signing-messages}

Typically, a cryptographic signature is performed on a cryptographic hash of a message rather than the message itself, which facilitates signing messages of varying size. However, in this report we will loosely use the term `message', and its symbol $\mathfrak{m}$, to refer to the message properly speaking and/or its hash value, unless specified.

Signing messages is a staple of Internet security that lets a message's recipient be confident its content is as intended by the signer. One common signature scheme is called ECDSA. See \cite{ecdsa}, ANSI X9.62, and \cite{Hankerson:2003:GEC:940321} for more on this topic.

The signature scheme we present here is an alternative formulation of the transformed Schnorr proof from before. Thinking of signatures in this way prepares us for exploring ring signatures in the next chapter.

\subsubsection*{Signature}

Assume Alice has the private/public key pair \((k_A, K_A)\). To unequivocally sign an arbitrary message $\mathfrak{m}$, she could execute the following steps:

\begin{enumerate}
	\item Generate random number $\alpha \in_R \mathbb{Z}_l$, and compute $\alpha G$.
	\item Calculate the challenge using a cryptographically secure hash function, \(c = \mathcal{H}(\mathfrak{m},[\alpha G])\).
	\item Define the response $r$ such that $\alpha = r + c*k_A$. In other words, $r = \alpha - c*k_A$.
	\item Publish the signature $(c, r)$.
\end{enumerate}

\subsubsection*{Verification}

Any third party who knows the EC domain parameters (specifying which elliptic curve was used), the signature $(c, r)$, the signing method, $\mathfrak{m}$, the hash function, and $K_A$ can verify the signature:

\begin{enumerate}
	\item Calculate the challenge: \(c' = \mathcal{H}(\mathfrak{m},[r G + c*K_A])\).
	\item If $c = c'$, then the signature passes.
\end{enumerate}

In this signature scheme we store two scalars, and need to know one public EC key.

\subsubsection*{Why it works}

This stems from the fact that
\begin{align*}
  	 r G &= (\alpha - c*k_A) G \\
  	  	 &= \alpha G - c*K_A \\
\alpha G &= r G + c*K_A \\
\mathcal{H}_n(\mathfrak{m},[\alpha G]) &= \mathcal{H}_n(\mathfrak{m},[r G + c*K_A]) \\
       c &= c'
\end{align*}

Therefore the owner of $k_A$ (Alice) created $(c,r)$ for $\mathfrak{m}$: she signed the message. The probability someone else, a forger without $k_A$, could have made $(c,r)$ is negligible, so a verifier can be confident the message was not tampered with.



%----------CURVE ED25519
\section{Curve Ed25519 and Ristretto}
\label{sec:ed25519-and-ristretto}

MobileCoin uses a particular twisted Edwards elliptic curve for cryptographic operations, {\em Ed25519}, the {\em birational equivalent}\footnote{\label{birational_note}Without giving further details, birational equivalence can be thought of as an isomorphism expressible using rational terms.} 
of the Montgomery curve {\em Curve25519}. It actually uses Ed25519 indirectly via the Ristretto encoding abstraction, which we will discuss. Both Curve25519 and Ed25519 were released by Bernstein {\em et al.} \cite{Bernstein2008-twisted-edwards, Bernstein2012-high-speed-high-security-ed25519, Bernstein2007-faster-ec-ops}.\\

The\marginnote{[dalek25519] src/const- ants.rs {\tt \#[test] test\_d\_vs\_ ratio()}} curve is defined over the prime field \(\mathbb{F}_{2^{255} - 19}\) (i.e.\ $q = 2^{255}-19$) by means of the following equation:\vspace{.155cm}
\[-x^2 + y^2 = 1 - \frac{121665}{121666} x^2 y^2\]

This curve addresses many concerns raised by the cryptography community.\footnote{Even if a curve appears to have no cryptographic security problems, it's possible the person/organization that created it knows a secret issue which only crops up in very rare curves. Such a person may have to randomly generate many curves in order to find one with a hidden weakness and no known weaknesses. If reasonable explanations are required for curve parameters, then it becomes even more difficult to find weak curves that will be accepted by the cryptographic community. Curve Ed25519 is known as a `fully rigid' curve, which means its generation process was fully explained. \cite{elliptic-curve-rigidity}} It is well known that NIST\footnote{\label{NIST_note}National Institute of Standards and Technology, \url{https://www.nist.gov/}.} 
standard algorithms have issues. For example, it has recently become clear the NIST standard random number generation algorithm PNRG (the version based on elliptic curves) is flawed and contains a potential backdoor \cite{hales2014nsa}. Seen from a broader perspective, standardization authorities like NIST lead to a cryptographic monoculture, introducing a point of centralization. A great example of this was illustrated when the NSA used its influence over NIST to weaken an international cryptographic standard \cite{NSA-NIST}.

Curve Ed25519 is not subject to any patents (see \cite{ECC-patents} for a discussion on this subject), and the team behind it has
developed\marginnote{[dalek25519] src/edw- ards.rs} and adapted basic cryptographic algorithms with efficiency in mind~\cite{Bernstein2007-faster-ec-ops}.

Twisted Edwards curves have order expressible as \(N=2^c l\), where \(l\) is a prime number and \(c\) is a positive integer. In the case of curve Ed25519, its order is a 76-digit number ($l$ is 253 bits):\footnote{This means private EC keys in Ed25519 are 253 bits.}\vspace{.175cm}
\[2^3 \cdot 7237005577332262213973186563042994240857116359379907606001950938285454250989\marginnote{[dalek25519] src/const- ants.rs {\tt BASEPOINT\_ ORDER}}\]


\subsection{Problem with cofactors}
\label{subsec:problem-cofactors}

As mentioned in Section \ref{subsec:group-theory}, only points in the large prime-order subgroup of a given elliptic curve are used in cryptographic algorithms. It is therefore sometimes important to make sure a given curve point belongs to that subgroup \cite{decaf}.

For example, it is possible to have multiple curve points that, when multiplied by the same scalar $n$, create the same resultant point. This can occur when $n$ is a multiple of $h$ and the points are created as sums between a prime-order point and different cofactor-order points. Multiplying by $n$ causes the cofactor-order component to `disappear'.\footnote{Cryptocurrencies that inherited the CryptoNote code base had an infamous vulnerability related to adding cofactor-subgroup points to normal-subgroup points. It was solved by checking that key images (discussed in Chapter \ref{chapter:advanced-schnorr}) are in the correct subgroup with the test $l \tilde{K} \stackrel{?}{=} 0$ \cite{key-image-bug}.}

To be clear, given some point $K$ in the subgroup of order $l$, any point $K^h$ with order $h$, and an integer $n$ divisible by $h$:
\begin{align*}
    n*(K + K^h) &= n K + n K^h\\
                &= n K + 0
\end{align*}

The importance of using prime-order-subgroup points was the motivation behind Ristretto, which is an encoding abstraction that can be applied to some elliptic curves (e.g.\ Ed25519). Ristretto efficiently constructs a prime-order group out of an underlying non-prime group. \cite{ristretto-motivation}


\subsection{Ristretto}
\label{subsec:ristretto}

Ristretto can be thought of as a `binning' procedure for points in the underlying curve. The number of bins is equal to the prime-order subgroup of the relevant curve ($l$), and each bin has $h$ elements.\footnote{In group theory, what we call bins are more correctly known as `cosets' \cite{coset-wikibooks}.} Curve operations `on' or `between' bins behave just like curve operations on the prime-order subgroup, except in this model rather than a specific point, the result is a specific bin.

This implies the members of a bin must be variants of a prime-order subgroup point (in other words, a prime-order point plus all the members of the cofactor-order subgroup, including the point-at-infinity). Given two bins, adding any of their members together will land you in the same third bin. In this way, curve operations on `Ristretto points', which are simple containers that can hold a bin member from any bin, behave just like operations on prime-order subgroup points.

For example, given Ristretto points
\begin{align*}
    P_1 &= P^{prime}_1 + P^{cofactor}_1 \\
    P_2 &= P^{prime}_2 + P^{cofactor}_2
\end{align*}
their sum $P_1 + P_2 = P_3$ will be
\begin{align*}
    P^{prime}_3 = P^{prime}_1 + P^{prime}_2 \\
    P^{cofactor}_3 = P^{cofactor}_1 + P^{cofactor}_2
\end{align*}

Here $P^{prime}_3$ defines which bin you landed in, and $P^{cofactor}_3$ corresponds to the specific member that was created.

Two members of the same bin are considered `equal'. There is a relatively cheap way to test equality, which we describe in Section \ref{subsec:point-compression-section}.\\

In each bin the point from the prime-order subgroup is the bin's `representative canonical member'. Moreover, that point can be easily found by `compressing' any of the bin members and then `decompressing' the result. This way curve points can be communicated in compressed form, and recipients can be assured they are handling effectively prime-order points and don't have to be concerned about cofactor-related problems.

As a bit of callback, given some point $K$ in the prime-order subgroup and two points $K^h_a, K^h_b$ in the cofactor-order subgroup, both $K + K^h_a$ and $K + K^h_b$ will compress and then decompress into the same point $K$.

Since all bin members get compressed to the same bit string, there is no `gotcha' (as there is with standard Ed25519) where presenting different compressed members of a bin to a byte-aware context (e.g.\ a hash function or byte-wise comparison) will have different results.


\subsection{Binary representation}
\label{subsec:binary_note}
Elements of \(\mathbb{F}_{2^{255} - 19} \) are encoded as 256-bit integers, so they can be represented using 32 bytes. Since each element only requires 255 bits, the most significant bit is always zero.

Consequently, any point in Ed25519 could be expressed using 64 bytes. By applying the Ristretto {\em point compression} technique, described below, however, it is possible to reduce this amount by half, to 32 bytes.


\subsection{Point compression}
\label{subsec:point-compression-section}

The Ed25519 curve has the property that its points can be easily compressed, so that representing a point will consume only the space of one coordinate. We will not delve into the mathematics necessary to justify this \cite{ristretto}, but we can give a brief insight into how it works. Normal point compression for the Ed25519 curve was standardized in \cite{eddsa-ed25519-irtf}, first described in \cite{Bernstein2012-high-speed-high-security-ed25519}, and the concept was introduced in \cite{Miller:point-compression-origin}.

As background, it's helpful to know that the normal point compression scheme follows from a transformation of the twisted Edwards curve equation (wherein $a = -1$): $x^2 = (y^2-1)/(d y^2+1)$,\footnote{Here $d = - \frac{121665}{121666}$.} which indicates there are two possible $x$ values ($+$ or $-$) for each $y$. Field elements $x$ and $y$ are calculated$\pmod{q}$, so there are no actual negative values. However, taking$\pmod{q}$ of $-x$ will change the value between odd and even since $q$ is odd. For example: $3 \pmod{5} = 3$, $-3 \pmod{5} = 2$. In other words, the field elements $x$ and $-x$ have different odd/even assignments.

If we have a curve point and know its $x$ is even, but given its $y$ value the transformed curve equation outputs an odd number, then we know negating that number will give us the right $x$. One bit can convey this information, and conveniently the $y$ coordinate has an extra bit.

Ristretto has a different approach to compressing points, where the sign of the $x$ coordinate is not encoded.

Assume we want to compress a point \((x, y)\). First we transform it into {\em extended twisted Edwards coordinates} \cite{twisted-edwards-revisited} $(X:Y:Z:T)$, where $X Y = Z T$ and $a X^2 + Y^2 = Z^2 + d T^2$.\vspace{.115cm}
\begin{align*}
    X &= x\\
    Y &= y\\
    Z &= 1 \\
    T &= xy \pmod q
\end{align*}

\begin{description}
    \item [Square Root: {\tt Sqrt(u, v)}] \hfill
        \begin{enumerate}
            \item Create\marginnote{[dalek25519] src/field.rs {\tt Field- Element:: sqrt\_ra- tio\_i()}} an algorithm for computing $\sqrt{u/v} \pmod q$.\footnote{These algorithms are merely shown for a sense of completeness. It's best to consult the {\tt dalek} library's implementation \cite{dalek-curve25519-lib}, the Ristretto Group's notes \cite{ristretto}, and the Ristretto/Decaf IETF draft \cite{ristretto-decaf-ietf} for any production-level applications.}
            
            \item Define $i = 2^{(q-1)/4} \pmod q$.

            \item Compute\footnote{Since $q = 2^{255}-19 \equiv 5 \pmod{8}$, $(q-5)/8$ and $(q-1)/4$ are straightforward integers.} \(z = u v^3 (u v^7)^{(q-5)/8} \pmod q\). Set {\tt nonzero-square = true}.
            \begin{enumerate}
                \item If \(v z^2 \stackrel{?}{=} u \pmod q\), set \(r = z\).
                \item If \(v z^2 \stackrel{?}{=} -u \pmod q\), calculate \(r = i*z \pmod q\).
                \item If \(v z^2 \stackrel{?}{=} i*(-u) \pmod q\), calculate \(r = i*z \pmod q\) and set {\tt nonzero-square = false}.
            \end{enumerate}

            \item If the least significant bit of $r$ is 1 (i.e.\ it is odd), return $-r$, otherwise return $r$. Also return the boolean {\tt nonzero-square}.\footnote{\label{footnote:point-comp-positive-convention-normal-decompression}According to the comments in {\tt [dalek] src/field.rs FieldElement::sqrt\_ratio\_i()}, only the `positive' square root should be returned, which is defined by convention in \cite{Bernstein2012-high-speed-high-security-ed25519} and \cite{ristretto-decaf-ietf} as field elements with the least significant bit not set (i.e.\ `even' field elements). In normal Ed25519 point decompression \cite{Bernstein2012-high-speed-high-security-ed25519} we would compute {\tt Sqrt}$(y^2 - 1, d y^2 + 1)$, then decide whether to use the `positive'/`negative' result variant depending on if we want the even/odd $x$ coordinate. Basically, a compressed point is the $y$ coordinate, with the most significant bit equal to 0 or 1 to indicate if the point's $x$ coordinate is even/odd.}
        \end{enumerate}

	\item[Encoding] \hfill
        \begin{enumerate}
            \item Define\marginnote{[dalek25519] src/ristr- etto.rs {\tt Ristretto- Point:: compress()}}
            \begin{enumerate}
                \item $u_1 = (Z + Y)*(Z - Y) \pmod q$
                \item $u_2 = X Y \pmod q$
            \end{enumerate}
    
            \item Let $\textrm{inv} = \textrm{{\tt Sqrt}}(1, u_1 u^2_2) \pmod q$.

            \item Define
            \begin{enumerate}
                \item $i_1 = u_1*\textrm{inv} \pmod q$
                \item $i_2 = u_2*\textrm{inv} \pmod q$
                \item $z_{inv} = i_1 i_2 T \pmod q$
            \end{enumerate}

            \item Let $b$ equal the least significant bit of $z_{inv} * T \pmod q$
            \begin{enumerate}
                \item If $b \stackrel{?}{=} 1$, define
                \begin{enumerate}
                    \item $X' = Y * 2^{(q-1)/4} \pmod q$
                    \item $Y' = X * 2^{(q-1)/4} \pmod q$
                    \item $D' = i_1 * \textrm{{\tt Sqrt}}(1, a - d) \pmod q$
                \end{enumerate}
                \item Otherwise if $b \stackrel{?}{=} 0$, define
                \begin{enumerate}
                    \item $X' = X$
                    \item $Y' = Y$
                    \item $D' = i_2$
                \end{enumerate}
            \end{enumerate}

            \item If $z_{inv} * X' \pmod q$ is odd, set $Y' = -Y' \pmod q$.

            \item Compute $s = D' * (Z - Y') \pmod q$. If $s$ is odd, set $s = -s \pmod q$.
            \item Return $s$.
        \end{enumerate}

    \item[Decoding] \hfill
        \begin{enumerate}
            \item Given\marginnote{[dalek25519] src/ristr- etto.rs {\tt Compress- edRistr- etto:: decompr- ess()}} a supposed compressed curve point $s$. Reject $s$ if it is odd or $\geq q$.

            \item Compute
            \[y = \frac{1 + a s^2}{1 - a s^2} \pmod q\]

            \item Compute ($x$ should be `even' after this step) the following. If {\tt nonzero-square} is {\tt false}, then the point is invalid.\vspace{.155cm}
            \[x = \textrm{{\tt Sqrt}}(4 s^2, a d (1 + a s^2)^2 - (1 - a s^2)^2) \pmod q\]

            \item Convert to extended coordinates. If $T$ is odd, then the point is invalid.\vspace{.115cm}
            \begin{align*}
                X &= x \\
                Y &= y \\
                Z &= 1 \\
                T &= x y \pmod q
            \end{align*}
	    \end{enumerate}
\end{description}

We can use extended coordinates to test\marginnote{[dalek25519] src/ristr- etto.rs {\tt Ristretto- Point:: ct\_eq()}} if two points belong to the same Ristretto bin. If either $X_1 Y_2 \stackrel{?}{=} Y_1 X_2$ or $Y_1 Y_2 \stackrel{?}{=} -a X_1 X_2$ holds, then the points $P_1 = (X_1 : Y_1 : Z_1 : T_1)$ and $P_2 = (X_2 : Y_2 : Z_2 : T_2)$ are `equal' for our purposes \cite{ristretto-equality}.\footnote{Since $a = -1$, the second test simplifies to $Y_1 Y_2 \stackrel{?}{=} X_1 X_2$.}\footnote{Multiple extended coordinates can represent a given curve point \cite{ristretto-what-is}, so $X$ may not always equal $x$, and the same for $Y$ and $y$. This equality test works for all extended coordinate representations.}\\

Implementations of Ed25519 typically use the generator $G = (x,4/5)$ \cite{Bernstein2012-high-speed-high-security-ed25519}, where x is the `even' variant based on normal point decompression (footnote \ref{footnote:point-comp-positive-convention-normal-decompression} from earlier in this section describes how it works) of \(y = 4/5 \pmod q\). The Ristretto generator is straightforwardly the bin that contains $G$, and the point\marginnote{[dalek25519] src/const- ants.rs {\tt RISTRETTO\_ BASEPOINT\_ POINT}} selected to represent it is $G$ itself.



\section{Binary operator XOR}
\label{sec:XOR_section}

The binary operator XOR is a useful tool that will appear in Section \ref{sec:pedersen-ringct}. It takes two arguments and returns true if one, but not both, of them is true \cite{wolfram-xor}. Here is its truth table:

\begin{center}
    \begin{tabular}{|c|c|c|}
    \hline
        A & B & A XOR B \\
    \hline\hline
        T & T & F \\
    \hline
        T & F & T \\
    \hline
        F & T & T \\
    \hline
        F & F & F \\
    \hline
    \end{tabular}
\end{center}

In the context of computer science, XOR is equivalent to bit addition modulo 2. For example, the XOR of two bit pairs:
\begin{alignat*}{1}
    \text{XOR}(\{1,1\},\{1,0\}) &= \{1+1,1+0\} \pmod 2 \\
                                &= \{0,1\} 
\end{alignat*}

Each of these also produce $\{0,1\}$: $\text{XOR}(\{1,0\},\{1,1\})$, $\text{XOR}(\{0,0\},\{0,1\})$, and $\text{XOR}(\{0,1\},\{0,0\})$. For XOR inputs with $b$ bits, there are $2^{\text{b}}$ total combinations of inputs that would make the same output. This means if $C = \text{XOR}(A,B)$ and input $A \in_R \{0,...,2^{\text{b}}-1\}$, an observer who learns $C$ would gain no information about $B$ (its real value could be any of $2^b$ possibilities).

At the same time, anyone who knows two of the elements in $\{A,B,C\}$, where $C = \text{XOR}(A,B)$, can calculate the third element, such as $A = \text{XOR}(B,C)$. XOR indicates if two elements are different or the same, so knowing $C$ and $B$ is enough to expose $A$. A careful examination of the truth table reveals this vital feature.\footnote{One interesting application of XOR (unrelated to MobileCoin) is swapping two bit registers without a third register. We use the symbol $\oplus$ to indicate an XOR operation. $A \oplus A = 0$, so after three XOR operations between the registers: $\{A, B\} \rightarrow{} \{[A \oplus B], B\} \rightarrow{} \{[A \oplus B], B \oplus [A \oplus B]\} = \{[A \oplus B], A \oplus 0\} = \{[A \oplus B], A\} \rightarrow{} \{[A \oplus B] \oplus A, A\} = \{B, A\}$.}